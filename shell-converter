#!/usr/bin/env python3

import argparse, csv, itertools, sys, time

# This maps a decoder's MAC address to a set of timelines it handles.
# The valid timeline names are 'Start', 'LapCtr', and 'Finish'.
# The same decoder can be used for multiple timelines, but combining
# 'LapCtr' and 'Finish' doesn't make much sense.
decoders = {
  '0004B704061D' : { 'Start', 'LapCtr' },
  '0004B7021482' : { 'Finish' },
  'STOP'         : { 'Finish' },
  }

def warn(rec, msg):
    file = rec['_file']
    line = rec['_line']
    stamp = rec.get('Time')
    print(f'{file}[{line}] ({stamp}): {msg}', file=sys.stderr, flush=True)

def process(inputs, outfile):
    # Read lines from all input files; then sort by timestamp
    data = list()
    for path in inputs:
        try:
          with open(path, encoding='cp1252', errors='replace') as f:
              reader = csv.DictReader(f, skipinitialspace=True)
              data.extend([
                  # Add file and line# to every record.
                  # We start at line 2, because line 1 is the header
                  # XXX look for missing timestamps
                  dict(**rec, _file=path, _line=lno)
                  for rec, lno in zip(reader, itertools.count(2))
                  ])
        except FileNotFoundError:
            print(f'WARNING: {path} not found', file=sys.stderr, flush=True)
    
    writer = csv.DictWriter(outfile,
      fieldnames = ['car', 'start', 'finish', 'laps' ],
      extrasaction = 'ignore', lineterminator='\n',
      )
    #writer.writeheader()
    active = dict()
    complete = []
    for rec in sorted(data, key = lambda x: x['Time']):
        chip   = rec.get('Code')
        device = rec.get('Device')
        car    = rec.get('No') or f'#{chip}'
        if car == 'unknown' or car == '-1':
            car = f'#{chip}'
    
        if chip   is None: warn(rec, 'Missing chip code')
        if device is None: warn(rec, 'Missing device (MAC address)')
        if chip is None or device is None:
            continue
        if device not in decoders:
            warn(rec, f'Unknown decoder {device}')
            continue
        timelines = decoders[device]
    
        run = active.get(chip)
        if run:
            # Chip has an active run; update as appropriate
            # NB: The order of these tests matters, since a single decoder
            # might fit multiple roles
            if 'Finish' in timelines:
                run['laps']   += 1
                run['finish'] = rec['Time']
                complete.append(run)
                del active[chip]
            elif 'LapCtr' in timelines:
                run['laps'] += 1
            elif 'Start' in timelines:
                warn(rec, f'Start passing abandons existing run for {chip} ({run["laps"]} laps since {run["start"]})')
                complete.append(run)
                active[chip] = dict(
                  chip  = chip,
                  car   = car,
                  start = rec['Time'],
                  laps  = 0
                  )
        elif 'Start' in timelines:
            # No active run for this chip
            active[chip] = dict(
              chip  = chip,
              car   = car,
              start = rec['Time'],
              laps  = 0
              )
        else:
            warn(rec, f'No active run for chip {chip}')
    
    complete.extend(active.values())
    for run in sorted(complete, key = lambda x: x['start']):
        writer.writerow(run)



def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('-d', '--debug', action='store_true',
      help='Enable debugging')
    ap.add_argument('-o', '--output', help='Output file')
    ap.add_argument('-s', '--sleep',  type=int, help='Delay between runs')
    ap.add_argument('input', nargs='+', help='Files to process')
    opts = ap.parse_args()

    while True:
        if opts.output:
            with open(opts.output, 'w') as output:
                process(opts.input, output)
        else:
            process(opts.input, sys.stdout)
        if opts.sleep:
            time.sleep(opts.sleep)
            #print('', file=sys.stderr, flush=True)
        else:
            break

main()

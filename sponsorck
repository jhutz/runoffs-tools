#!/usr/bin/perl

use Getopt::Std;
use IO::File;
use Text::CSV;
use strict;
use vars qw($Mode $DataFile $SponsorFile);
use vars qw(%Sponsors %Alt);

our @KeyCols = ('Class', 'Member #');
our $DataCol = 'Sponsor';
our $MaxLen  = 35;

sub usage (@) {
  print STDERR @_, "\n" if @_;
  print <<"EOF";
usage: $0 [-i | -u | -p] [-n | -g | -k key] [-F field] [-M max] data [sponsors]
       $0 -h
Operating Modes:
  -i  Incremental - only list new sponsors
  -u  Update - merge new sponsors into list
  -p  Patch - generate reg_apply patch with rewritten sponsors
  Sponsor input file required for -[iup]
  Default mode is to list all sponsors

Options:
  -n  Use class+no instead of class+memberID as key
  -g  Use group+class+no instead of class+memberID as key
  -k  Use specified fields as keys (comma-separated)
  -F  Use spcified field as sponsor field (default $DataCol)
  -M  Set maximum sponsor length (default $MaxLen)
  -h  Print this help message
EOF
  exit !!@_;
}

sub parse_args () {
  my %opts;

  getopts('hgik:npus:F:', \%opts) or usage("Invalid option!");
  usage()    if $opts{h};

  if ($opts{g} + $opts{n} + defined($opts{k}) > 1) {
    usage "Use at most one of -g -n, or -k";
  }
  if ($opts{n}) {
    @KeyCols = ('Class','No.');
  } elsif ($opts{g}) {
    @KeyCols = ('Group', 'Class','No.');
  } elsif ($opts{k}) {
    @KeyCols = split(/,/, $opts{k});
  }
  $DataCol = $opts{F} if exists $opts{F};

  if ($opts{i} + $opts{u} + $opts{p} > 1) {
    usage "Use at most one if -i, -u, or -p";
  }
  $Mode = 'i' if $opts{i};
  $Mode = 'u' if $opts{u};
  $Mode = 'p' if $opts{p};

  usage "Input filename required" unless @ARGV;
  usage "Sponsor input file required for -[iup]" if $Mode && @ARGV < 2;
  usage "Sponsor input file not used without -[iup]" if !$Mode && @ARGV > 1;
  usage "Too many arguments" if @ARGV > 2;

  ($DataFile, $SponsorFile) = @ARGV;
}

sub gen_alts ($) {
  # XXX 1) Drop Inc/LLC/....
  # XXX 2) drop whitespace
  # XXX 3) shorten Motorsports
  # XXX 4) shorten Motorsports  +  drop whitespace
  # XXX 5) drop Motorsports, Racing, ...?
  # XXX 6) drop Motorsports, Racing, ...?  +  drop whitespace
  return ();
}

sub rewrite (@) {
  my @sponsors = @_;
  return join('/', map($Sponsors{$_} // $_, @sponsors));
}


parse_args;

## Load existing sponsor table
if ($SponsorFile) {
  my $S = IO::File->new($SponsorFile, O_RDONLY) or die "$SponsorFile: $!\n";
  my $SC = new Text::CSV({ binary => 1, allow_whitespace => 1 });
  while (my $cols = $SC->getline($S)) {
    my($old, $new, @alts) = @$cols;
    next if $old eq '' || $new eq '';
    next if $Mode eq 'p' && $new eq '-';

    $Sponsors{$old} = $new;
    if ($Mode eq 'p') {
      # alternate sponsor name behavior for patch mode:
      @alts = gen_alts($new) if !@alts;  # empty means use default
      shift @alts if $alts[0] eq '-';    # - means use nothing
    }
    $Alt{$old} = [ @alts ];
  }
  $SC->error_diag();
  $S->close;
}

## Set up input file
my($F, $IN);
{
  $F = IO::File->new($DataFile, O_RDONLY) or die "$DataFile: $!\n";
  
  my $head = <$F>;
  $IN = new Text::CSV( { binary => 1,
      quote_space => 0,
      quote_binary => 0,
      ($head =~ /\t/) ? (
        sep_char    => "\t",
        quote_char  => ($head =~ /"/ ? '"' : undef),
        always_quote => ($head =~ /^"/ ? 1 : 0),
        escape_char => undef,
      ) : ()
    });
  $IN->parse($head) or die "failed parsing data column headers\n";
  my @head = $IN->fields();
  die "No column $DataCol in input!\n" unless grep($_ eq $DataCol, @head);
  $IN->column_names(@head);
}

# Set up for output
binmode STDOUT, ':utf8';
autoflush STDERR 1;
my $OUT = Text::CSV->new({ binary => 1, eol => "\n" });
$OUT->print(\*STDOUT, [qw[key field old new]]) if $Mode eq 'p';

# Process the data
while (my $hr = $IN->getline_hr($F)) {
  my $sponsor = $$hr{$DataCol};
  my @sponsors = split(m#\s*/\s*#, $sponsor);
  if ($Mode eq 'p') {
    # Patch mode -- compute a new sponsor and print a diff
    my $key = join('_', map($$hr{$_}, @KeyCols));
    my $nsponsor = rewrite(@sponsors);
    if (len($nsponsor) > $MaxLen) {
      printf STDERR ("%-6s %3s %-9s %-30s %2d %s\n",
        @$hr{'Class', 'No.', 'Member #', 'Name'}, len($nsponsor), $nsponsor);
    }
    next if $nsponsor eq $sponsor;
    $OUT->print(\*STDOUT, [ $key, $DataCol, $sponsor, $nsponsor ]);
  } elsif ($Mode eq 'i') {
    # Incremental mode - just emit new sponsors
    foreach (grep(!exists($Sponsors{$_}), @sponsors)) {
      $Sponsors{$_} = '';
      print "$_\n";
    }
  } else {
    # Generate/update modes
    $Sponsors{$_} //= '' foreach @sponsors;
  }
}
$IN->error_diag();
$F->close;

if (!$Mode) {
  # Generate mode - just print the list of sponsors
  print map("$_\n", sort { lc($a) cmp lc($b) } keys %Sponsors);
} elsif ($Mode eq 'u') {
  # Update mode - print an updated list
  foreach (sort { lc($a) cmp lc($b) || $a cmp $b } keys %Sponsors) {
    $OUT->print(\*STDOUT, [ $_, $Sponsors{$_}, @{$Alt{$_} // []} ]);
  }
}

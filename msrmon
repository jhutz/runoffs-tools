#!/usr/bin/env python3

import os
import sys
import collections
import functools
import itertools
import pprint
from copy import deepcopy
from datetime import datetime, timezone
from dateutil import parser as dateutil_parser, tz
import re
import argparse
import requests
import sqlite3
import csv
import json
import yaml

# These config options are pathnames
# They are subject to environment and ~ expansion, and if relative,
# will be interpreted relative to the location of the config file.
config_paths = ('database', 'pwfile')

# These command-line options can be set in the config file
opts_from_config = ('database', 'server', 'userid', 'password', 'pwfile',
            'org-id', 'event-id', 'segment-id', 'timezone')

# Default values for some options.
# Only needed for options that appear in opts_from_config
opts_defaults = { 'server' : 'api.motorsportreg.com' }

# Default configuration
config_defaults = {
    'csvFormats' : {},
    'csvEventQuestions' : [],
    'csvVehicleQuestions' : [],
}
config_default_csv = [
    { 'segment'        : 'Segment Name' },
    { 'vehicleNumber'  : 'No.' },
    { 'classShort'     : 'Class' },
    { 'groupShort'     : 'Group' },
    { 'lastName'       : 'Last Name' },
    { 'firstName'      : 'First Name' },
    { 'memberId'       : 'Member #' },
    { '_RoR'           : 'Region of Record Abbreviation' },
    { '_homeTown'      : 'City/State' },
    { '_MM'            : 'Vehicle Year/Make/Model' },
    { 'color'          : 'Color' },
    { 'transponder'    : 'Transponder ID' },
    { 'sponsor'        : 'Sponsor' },
    { 'registered'     : 'Registration date' },
    { 'uniqueId'       : 'Unique ID' },
]

# These fields are always irrelevant
always_irrelevant = [
    'id', 'lastUpdate', 'registered', 'data',
    'attendeeId', 'classId', 'classModifierId', 'groupId',
    'instructorprofileuri', 'instructoruri', 'memberuri',
    'profileuri', 'segmenturi', 'vehicleuri',
]


# columns in the database changes table
change_columns = [ 'uidAssignment', 'ts', 'authorName', 'authorEmail',
        'action', 'class', 'car', 'driver',
        'isCarChange', 'isRelevant', 'printed',
        'appliedA', 'appliedB', 'appliedC', 'appliedR' ]

# Required options for anything that connects to MSR
opts_msr_reqd = ('server', 'userid', 'password', 'org-id' )

# Query parameters for some MSR API calls
msr_member_params = { 'fields' : 'questions' }
msr_attendee_params = { 'fields' : 'questions' }
msr_assign_params = { 'fields' : 'vehicle_questions' }

# Relevant fields not included in member/assignment:
msr_member_only_fields = [ 'regionOfRecord', 'memberEnd', 'uniqueId' ]
msr_attendee_only_fields = [ 'lastUpdate', 'emergencyContact', 'emergencyPhone' ]
msr_attendee_only_fields2 = [ 'email', 'registered' ]

# Fields appearing in changes with different names than in the assignment
# The RHS is the name used in the assignment record, or None to ignore
msr_change_field_names = {
        ''                              : None,
        'classModifierShortdescription' : 'classModifier',
        'vehicleStatus'                 : 'vehiclestatus',
        'attendeeStatus'                : 'status',
        'vchclass'                      : 'classShort',
        'dateRegistered'                : 'registered',
        'uidvehicle'                    : None, # handled specially
        'uidmember'                     : None, #XXX
        'entrantEmail'                  : None,
        'entrantFirstName'              : None,
        'entrantLastName'               : None,
        'entrantMemberId'               : None,
        'clubMemberStatus'              : None,
        'clubName'                      : None,
        'eventName'                     : None,
        'part'                          : None,
        'uidclub'                       : None,
        }

# This is a terrible kludge!
ror_abbrev = {
  'Alamo'                              : 'Almo',
  'Arizona'                            : 'AZ',
  'Arizona Border'                     : 'AZB',
  'Atlanta'                            : 'Atl',
  'Big Sky'                            : 'BSky',
  'Blackhawk Valley'                   : 'BVR',
  'Blue Ridge'                         : 'BRR',
  'Buccaneer'                          : 'Bucc',
  'California Sports Car Club/CalClub' : 'CSCC',
  'Central Carolinas'                  : 'CCR',
  'Central Florida'                    : 'CFR',
  'Chicago'                            : 'CHI',
  'Cincinnati'                         : 'CIN',
  'Colorado'                           : 'Colo',
  'Continental Divide'                 : 'CDR',
  'Detroit'                            : 'DET',
  'Finger Lakes'                       : 'FLR',
  'Florida'                            : 'FLA',
  'Glen'                               : 'GLN',
  'Houston'                            : 'Hous',
  'Indianapolis'                       : 'IND',
  'Kansas'                             : 'KAN',
  'Kansas City'                        : 'KCR',
  "Land O' Lakes"                      : 'LOL',
  'Las Vegas'                          : 'LV',
  'Lone Star'                          : 'LnSt',
  'Mahoning Valley'                    : 'MVR',
  'Mid South'                          : 'MIDS',
  'Milwaukee'                          : 'Milw',
  'Mohawk-Hudson'                      : 'MHR',
  'Montana'                            : 'Mont',
  'Nebraska'                           : 'NEB',
  'Neohio'                             : 'NEO',
  'New England'                        : 'NER',
  'New York'                           : 'NYR',
  'North Carolina'                     : 'NCR',
  'Northeastern Penna'                 : 'NEP',
  'Northern New Jersey'                : 'NNJ',
  'Northwest'                          : 'Nwst',
  'Ohio Valley'                        : 'OVR',
  'Oklahoma'                           : 'OKLA',
  'Old Dominion'                       : 'ODR',
  'Oregon'                             : 'Ore',
  'Ozark Mountain'                     : 'OZMT',
  'Philadelphia'                       : 'PHL',
  'Reno'                               : 'Reno',
  'Rio Grande'                         : 'RioG',
  'San Diego'                          : 'SanD',
  'San Francisco'                      : 'SFR',
  'Snake River'                        : 'SnRv',
  'South Jersey (SJR)'                 : 'SJR',
# 'Southwest Division (SOWDiv)'        : '',
  'St. Louis'                          : 'STL',
  'Steel Cities'                       : 'STC',
  'Susquehanna'                        : 'SUS',
  'Tennessee'                          : 'TEN',
  'Texas'                              : 'Tex',
  'Washington DC'                      : 'WDC',
  'West Texas'                         : 'WTex',
  'Western Michigan'                   : 'WMR',
  'Western New York'                   : 'WNY',
  }

def load_config():
    """Load the config file, if any, and provide default values for options."""

    global Config
    Config = {}
    if Options.config is None:
        if 'HOME' in os.environ:
            def_cfg = os.path.join(os.environ['HOME'], '.msrmon')
        else:
            def_cfg = '.msrmon'
        if os.path.exists(def_cfg):
            Options.config = def_cfg
    if Options.config is not None:
        with open(Options.config) as cfg_file:
            Config = yaml.safe_load(cfg_file)
    for (k,v) in config_defaults.items():
        if k not in Config:
            Config[k] = v
    if 'timezone' in Config:
        Config['timezone'] = tz.gettz(Config['timezone'])
    if 'default' not in Config['csvFormats']:
        Config['csvFormats']['default'] = config_default_csv
    for key in config_paths:
        Config[key] = os.path.normpath(os.path.join(
            os.path.dirname(os.path.realpath(Options.config)),
            os.path.expandvars(os.path.expanduser(Config[key]))
            ))

    for key in opts_from_config:
        okey = key.replace('-','_')
        if key in Config and getattr(Options, okey, None) is None:
            setattr(Options, okey, Config[key])
    for key in opts_defaults.keys():
        if getattr(Options, key, None) is None:
            setattr(Options, key, opts_defaults[key])
    if Options.password is None and Options.pwfile is not None:
        with open(Options.pwfile) as pwfile:
            Options.password = pwfile.readline().strip()
    if 'irrelevantFields' in Config:
        Config['irrelevantFields'] = set(Config['irrelevantFields'])
        Config['irrelevantFields'].update(always_irrelevant)
    else:
        Config['irrelevantFields'] = set(always_irrelevant)

def is_uid(s):
    if not isinstance(s, str): return False
    if re.fullmatch('(?i)[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{16}$', s):
        return True
    return False

def parse_ts(timestr):
    if re.match('^[0-9]+$', timestr):
        return datetime.fromtimestamp(int(timestr), timezone.utc)
    else:
        return dateutil_parser.parse(timestr,
                default=datetime.now(timezone.utc).replace(
                    hour=0, minute=0, second=0, microsecond=0))

def convert_timestamp(val):
    datepart, timepart = val.split(b" ")
    year, month, day = map(int, datepart.split(b"-"))
    timepart, tzpart = timepart.split(b"+")
    timepart_full = timepart.split(b".")
    hours, minutes, seconds = map(int, timepart_full[0].split(b":"))
    if len(timepart_full) == 2:
        microseconds = int('{:0<6.6}'.format(timepart_full[1].decode()))
    else:
        microseconds = 0
    #XXX should handle tzpart, but it's always UTC anyway

    val = datetime(year, month, day, hours, minutes, seconds, microseconds)
    return val

sqlite3.register_converter("timestamp", convert_timestamp)

def format_ts(ts):
    if Options.raw_dates:
        return ts.strftime('%m/%d/%Y %H:%M:%S')
    lclts = ts.astimezone(Options.timezone)
    hour = int(lclts.strftime('%I'))
    return '{0.month}/{0.day}/{0:%y} {1}:{0:%M:%S %p}'.format(lclts, hour)

def dumpobj(obj):
    print(json.dumps(obj, sort_keys=True, indent=4))

def print_header(fmt, cols):
    def dash(x):
        if isinstance(x, collections.abc.Mapping):
            return { k : dash(v) for k, v in x.items() }
        else:
            return '='
    if Options.dump: return

    # KLUDGE: Standard format strings cannot start with %X, unless X is a valid
    # fill control mode. So, assume any such format is actually intended for
    # strftime, and actually _call_ strftime on a sample value to get its width.
    fmt = re.sub(r'{([^:]*):(%[^<=>^}][^}]*)}',
            lambda m : '{%s:%d}' % (m.group(1),
                len(datetime.now().strftime(m.group(2)))), fmt)
    fmt = re.sub(r'{([^:]*):[^}\d]*0?(\d+)[^}]*}', r'{\1:<\2}', fmt)
    print(fmt.format(**cols).rstrip())
    print(re.sub(r'{([^:]*):<(\d+)}', r'{\1:=<\2}', fmt).format(**dash(cols)))


def db_open():
    global DB
    if 'DB' in globals(): return
    DB = sqlite3.connect(Options.database, detect_types=sqlite3.PARSE_DECLTYPES)
    DB.row_factory = sqlite3.Row
    DB.executescript("""
create table if not exists assignments (
  aid           integer primary key,
  uid           text unique not null
);

create table if not exists assign_data (
  aid           integer not null references assignments,
  field         text not null,
  value         text,
  primary key (aid, field)
);

create table if not exists questions (
  qid           integer primary key,
  uid           text unique not null,
  kind          text not null,
  header        text not null,
  descr         text
);

create table if not exists answers (
  aid           integer not null references assignments,
  qid           integer not null references questions,
  answer        text,
  primary key (aid,qid)
);

create table if not exists changes (
  xid           integer primary key,
  uid           text unique not null,
  uidAssignment integer not null references assignments,
  ts            timestamp,
  action        text,
  authorName    text,
  authorEmail   text,
  class         text,
  car           text,
  driver        text,
  isCarChange   int(1),
  isRelevant    int(1),
  printed       int(1) not null default 0,
  appliedA      int(1) not null default 0,
  appliedB      int(1) not null default 0,
  appliedC      int(1) not null default 0,
  appliedR      int(1) not null default 0
);

create table if not exists change_data (
  xid           integer not null references changes,
  field         text not null,
  old_value     text,
  new_value     text,
  primary key (xid, field)
);

create table if not exists change_answers (
  xid           integer not null references changes,
  qid           integer not null references questions,
  old_answer    text,
  new_answer    text,
  primary key (xid,qid)
);
""")

QID_Cache = {}

def db_cache_qids(kind, info):
    needed = set([ x['id'] for x in info ]) - set(QID_Cache.keys())
    if needed:
        QID_Cache.update([ (x['uid'], x['qid'])
            for x in DB.execute('select uid, qid from questions') ])
        needed.difference_update(QID_Cache.keys())
    if needed:
        DB.executemany('''
            insert into questions (uid, header, descr,kind)
            values (:id,:header,:text,:kind)
            ''', [ dict(x, kind=kind) for x in info if x['id'] in needed ])
        QID_Cache.update([ (x['uid'], x['qid'])
            for x in DB.execute('select uid, qid from questions') ])

def db_store_answers(aid, kind, info):
    db_cache_qids(kind, info)
    DB.executemany('insert into answers (aid, qid, answer) values (?,?,?)',
            [ (aid, QID_Cache[x['id']], x['answer']) for x in info ])

def db_store_assign(rec):
    c = DB.execute('select aid from assignments where uid=?', (rec['id'],))
    r = c.fetchall()
    if r:
        aid = r[0]['aid']
        DB.execute('delete from assign_data where aid=?', (aid,))
        DB.execute('delete from answers where aid=?', (aid,))
    else:
        c = DB.execute('insert into assignments (uid) values (?)', (rec['id'],))
        aid = c.lastrowid
    DB.executemany('insert into assign_data (aid, field, value) values (?,?,?)',
            [ (aid, k, v) for k, v in rec.items() if not isinstance(v, (list, dict)) ])
    if 'questions' in rec:
        db_store_answers(aid, 'E', rec['questions'])
    if 'vehicle_questions' in rec:
        db_store_answers(aid, 'V', rec['vehicle_questions'])

def db_fetch_answers(item, kind):
    c = DB.execute('''
        select questions.uid as id, header, descr as text, answer
        from answers join assignments using (aid) join questions using (qid)
        where assignments.uid=? and questions.kind=?
        ''', (item, kind))
    return [ dict(row) for row in c ]

def db_fetch_assign(item):
    c = DB.execute('''
        select field,value
        from assignments join assign_data using (aid)
        where assignments.uid=?
        ''', (item,))
    rec = { x['field'] : x['value'] for x in c }
    rec['questions'] = db_fetch_answers(item, 'E')
    rec['vehicle_questions'] = db_fetch_answers(item, 'V')
    return rec

def db_find_assign(fields):
    c = DB.execute("select uid from assignments "
            + " ".join("join assign_data `a_{0}` using (aid)".format(x)
                for x in fields.keys())
            + " where "
            + " and ".join("`a_{0}`.field = '{0}' and `a_{0}`.value = :{0}".format(x)
                for x in fields.keys()), fields)
    return [ row['aid'] for row in c ]

def db_fetch_all_assigns():
    return [ db_fetch_assign(item[0])
            for item in DB.execute('select uid from assignments') ]

def db_store_change_answers(xid, kind, info):
    db_cache_qids(kind, info)
    DB.executemany('insert into change_answers (xid, qid, old_answer, new_answer) \
            values (?,?,?,?)',
            [ (xid, QID_Cache[x['id']], x['old_answer'], x['new_answer'])
                for x in info ])

def db_store_change(change, force=False):
    c = DB.execute('select xid from changes where uid=?', (change['uid'],))
    r = c.fetchall()
    if r:
        xid = change['xid'] = r[0]['xid']
        if not force:
            return False
        DB.execute('delete from change_data where xid=?', (xid,))
        DB.execute('update changes set (%s) = (%s) where xid = :xid'
                % ( ', '.join(change_columns),
                    ', '.join([ ':'+x for x in change_columns])),
                change)
    else:
        c = DB.execute('insert into changes (uid, %s) values (:uid, %s)'
                % ( ', '.join(change_columns),
                    ', '.join([ ':'+x for x in change_columns])),
                change)
        xid = change['xid'] = c.lastrowid
    if Options.debug:
        for field in sorted(change['affectedColumns']):
            args = (xid, field, change['old'].get(field), change['new'].get(field))
            sys.stderr.write('>> %4d %-25s %-25.25s %.25s\n' % args)
            DB.execute('insert into change_data (xid, field, old_value, new_value) \
                    values (?,?,?,?)',
                    (xid, field, change['old'].get(field), change['new'].get(field)))
    else:
        DB.executemany('insert into change_data (xid, field, old_value, new_value) \
                values (?,?,?,?)',
                [ (xid, field, change['old'].get(field), change['new'].get(field))
                    for field in change['affectedColumns'] ])
    db_store_change_answers(xid, 'E', change['questions'])
    db_store_change_answers(xid, 'V', change['vehicle_questions'])
    return True

def db_update_change(xid, data):
    if not data: return
    DB.execute('update changes set (%s) = (%s) where xid=:xid'
            % ( ','.join(data.keys()),
                ','.join(':' + x for x in data.keys())),
            dict(data, xid=xid))

def db_fetch_change_id(uid):
    c = DB.execute('select xid from changes where uid=?', (uid,))
    r = c.fetchall()
    if r:
        return r[0]['xid']
    else:
        return None

def db_fetch_change_answers(xid, kind):
    c = DB.execute('''
        select questions.uid as id, header, descr as text, old_answer, new_answer
        from change_answers join questions using (qid)
        where xid=? and questions.kind=?
        ''', (xid, kind))
    return [ dict(row) for row in c ]

def db_fetch_change(id):
    if re.match(r'^\d+$', id):
        c = DB.execute('select xid, uid, %s from changes where xid=?'
                % ', '.join(change_columns), (id,))
    else:
        c = DB.execute('select xid, uid, %s from changes where uid=?'
                % ', '.join(change_columns), (id,))
    r = c.fetchall()
    if not r: return None
    change = dict(r[0])
    c = DB.execute('select field, old_value, new_value from change_data where xid=?',
            (change['xid'],))
    fields = c.fetchall()
    change['affectedColumns'] = [ f['field'] for f in fields ]
    change['old'] = { f['field'] : f['old_value'] for f in fields }
    change['new'] = { f['field'] : f['new_value'] for f in fields }
    change['questions'] = db_fetch_change_answers(change['xid'], 'E')
    change['vehicle_questions'] = db_fetch_change_answers(change['xid'], 'V')
    return change

def db_fetch_all_changes():
    return [ db_fetch_change(item[0])
            for item in DB.execute('select uid from changes') ]

def msr_session():
    global MSR
    if 'MSR' not in globals():
        MSR = requests.Session()
        MSR.auth = (Options.userid, Options.password)
        MSR.headers.update({ 'X-Organization-Id' : Options.org_id })
    return MSR

def msr_get(query, params={}):
    sess = msr_session()
    if Options.debug:
        sys.stderr.write('msr_get(%s)\n' % query)
        pprint.pprint(params, stream=sys.stderr)
    r = sess.get('https://%s/rest/%s.json' % (Options.server, query), params = params)
    r.raise_for_status()
    return r.json()

def _msr_cleanup(obj):
    if isinstance(obj, list): return [ _msr_cleanup(x) for x in obj ]
    if isinstance(obj, dict): return { k : _msr_cleanup(v) for k,v in obj.items() }
    if isinstance(obj, str): return obj.strip()
    return obj

def _msr_load_fake_members():
    global Fake_Members
    if 'Fake_Members' not in globals():
        if Options.debug:
            sys.stderr.write('Loading fake members from %s\n' % Options.member_data.name)
        j = json.load(Options.member_data)
        Fake_Members = collections.OrderedDict(
                [ (x['id'], x) for x in map(_msr_cleanup, j) ] )
        if Options.debug:
            sys.stderr.write('Loaded %d fake members\n' % len(Fake_Members))

def msr_get_member(item):
    if Options.debug: sys.stderr.write('GET MEMBER %s\n' % item)
    if Options.member_data is not None:
        _msr_load_fake_members()
        return deepcopy(Fake_Members.get(item, None))
    j = msr_get('members/%s' % item, msr_member_params)
    try: rec = j['response']['member']
    except KeyError: return None
    return _msr_cleanup(rec)

def msr_get_member_list(cleanup=True):
    if Options.member_data is not None:
        _msr_load_fake_members()
        return [ deepcopy(x) for x in Fake_Members.values() ]
    j = msr_get('members', params=msr_member_params)
    if cleanup:
        return map(_msr_cleanup, j['response']['members'])
    return j['response']['members']

def msr_get_member_dict(cleanup=True):
    if Options.member_data is not None:
        _msr_load_fake_members()
        return { k : deepcopy(v) for k,v in Fake_Members.items() }
    j = msr_get('members', params=msr_member_params)
    if cleanup:
        return { x['id'] : _msr_cleanup(x) for x in j['response']['members'] }
    return { x['id'] : x for x in j['response']['members'] }


def _msr_load_fake_attendees():
    global Fake_Attendees
    if 'Fake_Attendees' not in globals():
        if Options.debug:
            sys.stderr.write('Loading fake attendees from %s\n' % Options.attendee_data.name)
        j = json.load(Options.attendee_data)
        for rec in j: _msr_cleanup(rec)
        Fake_Attendees = collections.OrderedDict(
                [ (x['id'], x) for x in map(_msr_cleanup, j) ] )
        if Options.debug:
            sys.stderr.write('Loaded %d fake attendees\n' % len(Fake_Attendees))

def msr_get_attendee(item):
    if Options.debug: sys.stderr.write('GET ATTENDEE %s\n' % item)
    if Options.attendee_data is not None:
        _msr_load_fake_attendees()
        return deepcopy(Fake_Attendees.get(item, None))
    j = msr_get('events/%s/attendees/%s' % (Options.event_id, item),
            params = msr_attendee_params)
    try: rec = j['response']['attendees'][0]
    except IndexError: return None
    return _msr_cleanup(rec)

def msr_get_attendee_list(cleanup=True):
    if Options.attendee_data is not None:
        _msr_load_fake_attendees()
        return [ deepcopy(x) for x in Fake_Attendees.values() ]
    j = msr_get('events/%s/attendees' % Options.event_id,
            params = msr_attendee_params)
    if cleanup:
        return map(_msr_cleanup, j['response']['attendees'])
    return j['response']['attendees']

def msr_get_attendee_dict(cleanup=True):
    if Options.attendee_data is not None:
        _msr_load_fake_attendees()
        return { k : deepcopy(v) for k,v in Fake_Attendees.items() }
    j = msr_get('events/%s/attendees' % Options.event_id,
            params = msr_attendee_params)
    if cleanup:
        return { x['id'] : _msr_cleanup(x) for x in j['response']['attendees'] }
    return { x['id'] : x for x in j['response']['attendees'] }


def _msr_load_fake_assigns():
    global Fake_Assigns
    if 'Fake_Assigns' not in globals():
        if Options.debug:
            sys.stderr.write('Loading fake assignments from %s\n' % Options.assign_data.name)
        j = json.load(Options.assign_data)
        for rec in j: _msr_cleanup(rec)
        Fake_Assigns = collections.OrderedDict(
                [ (x['id'], x) for x in map(_msr_cleanup, j) ] )
        if Options.debug:
            sys.stderr.write('Loaded %d fake assignments\n' % len(Fake_Assigns))

def msr_get_assign(item):
    if Options.debug: sys.stderr.write('GET ASSIGN %s\n' % item)
    if Options.assign_data is not None:
        _msr_load_fake_assigns()
        return deepcopy(Fake_Assigns.get(item, None))
    j = msr_get('events/%s/assignments/%s' % (Options.event_id, item),
            msr_assign_params)
    try: rec = j['response']['assignments'][0]
    except IndexError: return None
    return _msr_cleanup(rec)

def msr_get_assign_list(cleanup=True):
    if Options.assign_data is not None:
        _msr_load_fake_assigns()
        return [ deepcopy(x) for x in Fake_Assigns.values() ]
    j = msr_get('events/%s/segments/%s/assignments' %
            (Options.event_id, Options.segment_id),
            msr_assign_params)
    if cleanup:
        return map(_msr_cleanup, j['response']['assignments'])
    return j['response']['assignments']


def msr_add_member_info(rec, cache=None, mem=None):
    """Augment an assignment or attendee by adding data from the member record."""
    if mem is None:
        uri = rec['memberuri']
        id = uri.replace('/members/','')
        if cache is None:
            mem = msr_get_member(id)
        elif id not in cache:
            mem = cache[id] = msr_get_member(id)
        else:
            mem = cache[id]
    rec.update((k, mem[k]) for k in msr_member_only_fields)
    ror = mem['regionOfRecord']
    rec['_RoR'] = ror_abbrev.get(ror, ror)

def msr_add_attendee_info(rec, cache=None, att=None):
    """Augment an assignment by adding data from the attendee record."""
    if att is None:
        id = rec['attendeeId']
        if cache is None:
            att = msr_get_attendee(id)
        elif id not in cache:
            att = cache[id] = msr_get_attendee(id)
        else:
            att = cache[id]
    rec.update([ (k, att[k]) for k in msr_attendee_only_fields])
    rec.update([ (k, att[k]) for k in msr_attendee_only_fields2])
    rec['questions'] = att['questions']

def msr_get_changes(cleanup=True):
    if Options.change_data is not None:
        if not Options.change_data:
            sys.stderr.write('Out of fake change data\n')
            return []
        file = Options.change_data.pop(0)
        if Options.debug:
            sys.stderr.write('Loading fake changes from %s\n' % file.name)
        j = json.load(file)
        fake_changes = _msr_cleanup(j)
        if Options.debug:
            sys.stderr.write('Loaded %d fake changes\n' % len(fake_changes))
        return fake_changes

    params = { 'segments' : Options.segment_id }
    # XXX look up last known change in database
    if Options.since is not None:
        params['since'] = Options.since.strftime('%Y-%m-%d %H:%M:%S.%f')
    j = msr_get('events/%s/feeds/timing' % Options.event_id, params=params)
    if not j['success']:
        sys.stderr.write('MSR API request failed:')
        for e in j['errors']:
            sys.stderr.write(e)
        sys.exit(1)
    if cleanup:
        return map(_msr_cleanup, j['data'])
    return j['data']


def eval_custom_field(rec, Q, name, defn):
    postproc = []
    if Options.debug:
        sys.stderr.write('eval_custom_field(%s):\n' % name)
        pprint.pprint(defn, stream=sys.stderr)
    if isinstance(defn, list):
        # Definition has modifiers
        (defn, *postproc) = defn
    if isinstance(defn, collections.abc.Mapping):
        if len(defn) != 1:
            raise ValueError("Choice mapping must have exactly one key")
        (ref, table) = next(iter(defn.items()))
        if not isinstance(table, collections.abc.Mapping):
            raise TypeError("Choice mapping table must be a mapping")
        if Options.debug: sys.stderr.write('  choice(%s(%s))\n' % (ref, rec.get(ref)))
        value = eval_custom_field(rec, Q, name + '+',
                table.get(rec.get(ref), table.get(None)))
    elif is_uid(defn):
        # Question UID; None if question is not present
        if Options.debug: sys.stderr.write('  question(%s)\n' % defn)
        value = Q.get(defn)
    elif isinstance(defn, str):
        # Format string
        if Options.debug: sys.stderr.write('  format(%s)\n' % defn)
        srec = collections.defaultdict(str,
                { k : v if v is not None else '' for k,v in rec.items() })
        value = defn.format(**srec).strip()
    else:
        # Other scalar values are used as-is
        if Options.debug: sys.stderr.write('  literal(%s)\n' % str(defn))
        value = defn
    if Options.debug: sys.stderr.write('  value is [%s]\n' % str(value))

    for op in postproc:
        if isinstance(op, collections.abc.Mapping):
            # Value remapping
            if Options.debug:
                sys.stderr.write('  remap value: %s\n' % pprint.pformat(op))
            nv = op.get(value, op.get(None, {}))
            if Options.debug:
                sys.stderr.write('     new defn: %s\n' % pprint.pformat(nv))
            if isinstance(nv, collections.abc.Mapping) and len(nv) == 0:
                # The empty mapping means "don't change it"
                continue
            value = eval_custom_field(rec, Q, name + '>', nv)
            if Options.debug:
                sys.stderr.write('    new value: [%s]\n' % str(value))
        elif isinstance(op, str):
            # Pattern splitting
            if Options.debug:
                sys.stderr.write('  split: %s\n' % op)
            pat = re.compile(op)
            newf = { k : None for k in pat.groupindex.keys() }
            if value is not None:
                m = pat.search(value)
                if m:
                    newf = m.groupdict()
                    if Options.debug:
                        sys.stderr.write('  matched %d fields\n' % len(newf))
            if Options.debug:
                pprint.pprint(newf, stream=sys.stderr)
            rec.update(newf)
            rec['CF'].update(newf)
    if Options.debug: sys.stderr.write('\n')
    return value

def build_custom_fields(rec):
    if Options.debug:
        sys.stderr.write('build_custom_fields:\n')
        pprint.pprint(rec, stream=sys.stderr)
    rec['CF'] = {}
    if 'CustomFields' not in Config: return
    if not isinstance(Config['CustomFields'], collections.abc.Sequence):
        Config['CustomFields'] = [ Config['CustomFields'] ]

    Q = {}
    if 'questions' in rec:
        Q.update([ (q['id'], q['answer']) for q in rec['questions'] ])
    if 'vehicle_questions' in rec:
        Q.update([ (q['id'], q['answer']) for q in rec['vehicle_questions'] ])
    if Options.debug:
        pprint.pprint(Q, stream=sys.stderr)
    for cfset in Config['CustomFields']:
        for cf, defn in cfset.items():
            rec[cf] = rec['CF'][cf] = eval_custom_field(rec, Q, cf, defn)


def do_events():
    j = msr_get('calendars/organization/%s' % Options.org_id,
            params = { 'archive' : 'true' } if Options.archive else {})
    if Options.dump:
        dumpobj(j)
        return
    if Options.long:
        fmt = '{id:35} {name:30.30} {start:10} {venue[name]:10}'
    else:
        fmt = '{id:35} {name:30}'
    col_headers = {
            'id'    : 'Event ID',
            'name'  : 'Event Name',
            'start' : 'Date',
            'venue' : { 'name' : 'Venue' },
            }
    print_header(fmt, col_headers)
    for rec in j['response']['events']:
        print(fmt.format(**rec).rstrip())


def do_segments():
    j = msr_get('events/%s/segments' % Options.event_id)
    if Options.dump:
        dumpobj(j)
        return
    fmt = '{id:35} {name:30}'
    col_headers = {
            'id'    : 'Segment ID',
            'name'  : 'Segment Name',
            }
    print_header(fmt, col_headers)
    for rec in j['response']['segments']:
        print(fmt.format(**rec).rstrip())
        if Options.verbose:
            class_map = { x['id'] : x['shortName'] for x in seg['classes'] }
            for grp in sorted(seg['groups'], key=lambda x: x['shortName']):
                classes = [ class_map[x['classId']]
                        for x in seg['classToGroupMaps'] if x['groupId'] == grp['id'] ]
                if classes:
                    print('    ', grp['shortName'], '('+', '.join(sorted(classes))+')')
                else:
                    print('    ', grp['shortName'])


def do_members():
    if Options.items:
        recs = [ msr_get_member(item) for item in Options.items ]
    else:
        recs = msr_get_member_list(cleanup=not Options.dump)

    if Options.dump:
        dumpobj(recs)

def do_attendees():
    if Options.items:
        recs = [ msr_get_attendee(item) for item in Options.items ]
    else:
        recs = msr_get_attendee_list(cleanup=not Options.dump)

    if Options.dump:
        dumpobj(recs)
        return
    if Options.long:
        fmt = '{memberId!s:8} {_fullName:30.30} {_homeTown:25.25} {email:30.30} {registered:19} {lastUpdate:19}'
    else:
        fmt = '{memberId!s:8} {_fullName:30.30} {registered/date:10}'
    col_headers = {
            'memberId'        : 'Member #',
            'firstName'       : 'First Name',
            'lastName'        : 'Last Name',
            '_fullName'       : 'Name',
            '_homeTown'       : 'Home Town',
            'email'           : 'Email Address',
            'registered'      : 'Registration Date',
            'registered/date' : 'Registered',
            'lastUpdate'      : 'Last Updated',
            'lastUpdate/date' : 'Last Updated',
            }

    print_header(fmt, col_headers)
    for data in recs:
        reg = parse_ts(data['registered'])
        upd = parse_ts(data['lastUpdate'])
        data['_fullName'] = ' '.join((str(data['firstName']), str(data['lastName'])),)
        data['_homeTown'] = ' '.join((str(data['city']),      str(data['region'])),)
        data['registered/date'] = reg.astimezone(Options.timezone).strftime('%Y-%m-%d')
        data['lastUpdate/date'] = upd.astimezone(Options.timezone).strftime('%Y-%m-%d')
        if not raw_dates:
            data['registered'] = format_ts(reg)
            data['lastUpdate'] = format_ts(upd)

        print(fmt.format(**data).rstrip())
        if Options.questions:
            for q in sorted([ (q['header'], q['answer']) for q in data['questions'] ]):
                print('  {0:35} {1}'.format(*q))


def show_assign_csv(recs, att_cache=None, mem_cache=None, fromdb=False):
    # Set up columns
    fields = []
    header = {}
    if not Options.csv_format:
        Options.csv_format = 'default'
    if Options.csv_format not in Config['csvFormats']:
        raise KeyError("No CSV format '%s'" % Options.csv_format)
    for field in Config['csvFormats'][Options.csv_format]:
        if not isinstance(field, dict):
            k = v = field
        elif len(field) != 1:
            raise ValueError("CSV field mapping must have exactly one key")
        else:
            (k,v) = next(iter(field.items()))
        fields.append(k)
        header[k] = v
    if Options.event_questions:
        # Add event question columns
        if fromdb:
            att_data = recs
        else:
            if att_cache is None: att_cache = {}
            if not att_cache:
                for id in [ rec['id'] for rec in recs ]:
                    att_cache[id] = msr_get_attendee(id)
            att_data = att_cache
        Q = { q['header'] : q['id'] for rec in att_data for q in rec['questions'] }
        header.update((v,k) for k,v in Q.items())
        fields.extend(Q.pop(f,f) for f in Config['csvEventQuestions'])
        header.update((f,f) for f in fields if f not in header)
        fields.extend(sorted(Q.values()))
    if Options.vehicle_questions:
        # Add vehicle question columns
        Q = { q['header'] : q['id'] for rec in recs for q in rec['vehicle_questions'] }
        header.update((v,k) for k,v in Q.items())
        fields.extend(Q.pop(f,f) for f in Config['csvVehicleQuestions'])
        header.update((f,f) for f in fields if f not in header)
        fields.extend(sorted(Q.values()))

    if Options.tsv:
        writer = csv.DictWriter(sys.stdout, fieldnames=fields,
                extrasaction='ignore', quoting=csv.QUOTE_NONE, delimiter='\t')
    else:
        writer = csv.DictWriter(sys.stdout, fieldnames=fields,
                extrasaction='ignore', quoting=csv.QUOTE_ALL)
    writer.writerow(header)

    for data in recs:
        if not fromdb:
            msr_add_member_info(data, cache=mem_cache)
            msr_add_attendee_info(data, cache=att_cache)
        build_custom_fields(data)
        data['_fullName'] = ' '.join((str(data['firstName']), str(data['lastName'])),)
        data['_homeTown'] = ' '.join((str(data['city']),      str(data['region'])),)
        data['_MM']       = ' '.join((str(data['make']),      str(data['model'])),)
        data['registered'] = format_ts(parse_ts(data['registered']))
        data['lastUpdate'] = format_ts(parse_ts(data['lastUpdate']))
        if (Options.filter and not
                functools.reduce(lambda x,f: x and f[1].search(data[f[0]]),
                    Options.filter, True)):
            continue
        if 'questions' in data:
            data.update([ (q['id'], q['answer']) for q in data['questions'] ])
        if 'vehicle_questions' in data:
            data.update([ (q['id'], q['answer']) for q in data['vehicle_questions'] ])
        writer.writerow(data)


def show_assign_results(recs, att_cache=None, mem_cache=None, fromdb=False):
    if Options.sort:
        recs = sorted(recs, key=lambda r:
                (r['classShort'],
                    int(r['vehicleNumber']) if re.match('^\d+$', r['vehicleNumber']) else 0,
                    r['vehicleNumber'].startswith('0')))
    if Options.dump:
        dumpobj(recs)
        return
    if Options.csv or Options.tsv or Options.csv_format:
        show_assign_csv(recs, att_cache=att_cache, mem_cache=mem_cache, fromdb=fromdb)
        return

    if Options.long:
        fmt = '{vehicleNumber!s:>3} {classShort:6} {_fullName:30.30} {memberId!s:8} {transponder!s:8} {year!s:4} {make:20.20} {model:20.20} {color:15.15} {sponsor:20}'
    else:
        fmt = '{vehicleNumber!s:>3} {classShort:6} {_fullName:30.30} {transponder!s:8} {year!s:4} {_MM:22}'
    col_headers = {
            'vehicleNumber'   : 'No.',
            'classShort'      : 'Class',
            '_fullName'       : 'Name',
            'transponder'     : 'Tx #',
            'year'            : 'Year',
            '_MM'             : 'Make/Model',
            'make'            : 'Make',
            'model'           : 'Model',
            'color'           : 'Color',
            'memberId'        : 'Member #',
            '_homeTown'       : 'Home Town',
            'sponsor'         : 'Sponsor',
            }
    print_header(fmt, col_headers)

    for data in recs:
        if Options.custom_fields and not fromdb:
            msr_add_member_info(data, cache=mem_cache)
            msr_add_attendee_info(data, cache=att_cache)
        elif Options.event_questions and not fromdb:
            msr_add_attendee_info(data, cache=att_cache)
        if Options.custom_fields:
            build_custom_fields(data)
        data['_fullName'] = ' '.join((str(data['firstName']), str(data['lastName'])),)
        data['_homeTown'] = ' '.join((str(data['city']),      str(data['region'])),)
        data['_MM']       = ' '.join((str(data['make']),      str(data['model'])),)
        data['registered'] = format_ts(parse_ts(data['registered']))
        data['lastUpdate'] = format_ts(parse_ts(data['lastUpdate']))
        if (Options.filter and not
                functools.reduce(lambda x,f: x and f[1].search(data[f[0]]),
                    Options.filter, True)):
            continue
        print(fmt.format(**data).rstrip())
        if Options.verbose:
            for f in sorted((k,v) for k,v in data.items()
                    if not isinstance(v, list) and not isinstance(v, dict)):
                print('  {0:38} {1}'.format(*f))
        if Options.event_questions:
            for q in sorted([ (q['header'], q['answer']) for q in data['questions'] ]):
                print('  EQ:{0:35} {1}'.format(*q))
        if Options.vehicle_questions:
            for q in sorted([ (q['header'], q['answer']) for q in data['vehicle_questions'] ]):
                print('  VQ:{0:35} {1}'.format(*q))
        if Options.custom_fields:
            for q in sorted(data['CF'].items()):
                print('  CF:{0:35} {1}'.format(*q))

def do_assigns():
    att_cache = {}
    mem_cache = {}
    if Options.items:
        recs = [ msr_get_assign(item) for item in Options.items ]
    else:
        recs = msr_get_assign_list(cleanup=not Options.dump)
        if Options.custom_fields or Options.csv or Options.tsv or Options.csv_format:
            mem_cache = msr_get_member_dict(cleanup=not Options.dump)
            att_cache = msr_get_attendee_dict(cleanup=not Options.dump)
        elif Options.event_questions:
            att_cache = msr_get_attendee_dict(cleanup=not Options.dump)
    show_assign_results(recs, att_cache, mem_cache)


def do_download():
    db_open()
    recs = msr_get_assign_list()
    att_cache = msr_get_attendee_dict()
    mem_cache = msr_get_member_dict()
    with DB:
        for data in recs:
            msr_add_member_info(data, cache=mem_cache)
            msr_add_attendee_info(data, cache=att_cache)
            db_store_assign(data)


def do_entries():
    db_open()
    with DB:
        if Options.items:
            recs = [ db_fetch_assign(item) for item in Options.items ]
        else:
            recs = db_fetch_all_assigns()
    show_assign_results(recs, fromdb=True)


def do_update():
    def qdiff(old, new):
        diff = { x['id'] : {
            'id' : x['id'], 'header' : x['header'], 'text' : x['text'],
            'old_answer' : x['answer'], 'new_answer' : None
            } for x in old }
        for x in new:
            if x['id'] not in diff:
                diff[x['id']] = {
                        'id' : x['id'], 'header' : x['header'], 'text' : x['text'],
                        'old_answer' : None, 'new_answer' : x['answer']
                        }
            elif str(diff[x['id']]['old_answer']) != str(x['answer']):
                diff[x['id']]['new_answer'] = x['answer']
            else:
                del diff[x['id']]
        return diff.values()

    db_open()
    for change in sorted(msr_get_changes(), key=lambda x : x['ts']):
        if Options.debug:
            sys.stderr.write('processing change %s\n' % change['uid'])
            pprint.pprint(change, stream=sys.stderr)
        # Generate some change metadata fields
        cb = change.get('changedBy',{})
        change['authorName'] = ' '.join((cb.get('firstName'), cb.get('lastName'))).strip()
        change['authorEmail'] = cb.get('email')
        change['ts'] = parse_ts(change['ts'])
        change.update((x, False) for x in 
                [ 'printed', 'appliedA', 'appliedB', 'appliedC', 'appliedR' ])

        # affectedColumns is not very useful; it misses columns which were deleted,
        # ignores some columns entirely, and is inconsistent about whether it uses
        # the field names from old/new, afterchange, or the assignment record.
        # So, throw it away and recompute it from the old/new keys
        change['affectedColumns'] = set(change['old'].keys() | change['new'].keys())

        # determine what kind of change this is
        if (change['new'].get('attendeeStatus') not in (None, '', 'Cancelled')
                and 'attendeeStatus' not in change['old']):
            # This is a new assignment (possibly a new attendee) that didn't exist before
            change['action'] = 'NEW'
        elif (change['new'].get('attendeeStatus') not in (None, '', 'Cancelled')
            and change['old'].get('attendeeStatus') == 'Cancelled'):
            # This is reinstatement of a previously-cancelled attendee
            # Note that this can only happen if the attendee had cancelled entirely.
            # If a single assignment is removed, it cannot be reinstated
            # (but a new assignment can be created for the same class)
            change['action'] = 'REST'
        elif (change['new'].get('attendeeStatus') in (None, '', 'Cancelled') and
            change['old'].get('attendeeStatus') not in (None, '', 'Cancelled')):
            # An assignment has been deleted, or the attendee cancelled entirely.
            change['action'] = 'DROP'
        else:
            # Anything else is a modification to an existing assignment
            change['action'] = 'UPD'
        if 'attendeeStatus' in change['old'] and 'attendeeStatus' not in change['new']:
            # Fake up a status for deleted assignments.
            change['new']['attendeeStatus'] = 'DELETED';

        # Prefetch some related data from MSR
        asn = msr_get_assign(change['uidAssignment'])
        att = msr_get_attendee(change['attendeeId'])
        mem = msr_get_member(att['memberuri'].replace('/members/',''))

        with DB:
            if change['action'] == 'NEW':
                ### New or reinstatement
                # Generate metadata for this change
                change['isRelevant']  = True
                change['isCarChange'] = False
                change['class']       = change['new'].get('vchclass')
                change['car']         = change['new'].get('vehicleNumber')
                change['driver']      = ' '.join((
                            change['new'].get('firstName', ''),
                            change['new'].get('lastName', '')
                            )).strip()

                # If there was an existing DELETED assignment for the same
                # class+memberId, then this is really a reinstatement
                if db_find_assign( {
                    'class'    : change['afterChange']['classShort'],
                    'memberId' : change['afterChange']['memberId'],
                    'status'   : 'DELETED'
                    }):
                    change['action'] = 'REST'

                # Add the new assignment to the database
                new_rec = dict([
                        (msr_change_field_names.get(field, field), change['new'].get(field))
                        for field in change['affectedColumns']
                        if msr_change_field_names.get(field, field) is not None
                        ],
                    id                = asn['id'],
                    attendeeId        = att['id'],
                    memberuri         = mem['uri'],
                    vehicle_questions = asn['vehicle_questions'],
                    vehicleuri = mem['uri'] + '/vehicles/' + change['new']['uidvehicle']
                    )
                msr_add_member_info(new_rec, mem=mem)
                msr_add_attendee_info(new_rec, att=att)
                db_store_assign(new_rec)

                # Add member and attendee fields to the change
                change['affectedColumns'].update(msr_member_only_fields)
                change['affectedColumns'].update(msr_attendee_only_fields)
                change['old'].update((field, None)
                        for field in msr_member_only_fields + msr_attendee_only_fields)
                change['new'].update((field, new_rec[field])
                        for field in msr_member_only_fields + msr_attendee_only_fields)

                # Add event and vehicle questions to the change
                change['questions'] = [ {
                        'id' : x['id'], 'header' : x['header'], 'text' : x['text'],
                        'old_answer' : None, 'new_answer' : x['answer'] }
                        for x in new_rec['questions'] ]
                change['vehicle_questions'] = [ {
                        'id' : x['id'], 'header' : x['header'], 'text' : x['text'],
                        'old_answer' : None, 'new_answer' : x['answer'] }
                        for x in new_rec['vehicle_questions'] ]

                # Build custom fields and add them to the change
                build_custom_fields(new_rec)
                change['affectedColumns'].update(new_rec['CF'].keys())
                change['old'].update((field, None) for field in new_rec['CF'].keys())
                change['new'].update(new_rec['CF'])

            elif change['action'] == 'UPD' or change['action'] == 'REST':
                ### Update to an existing assignment
                old_rec = db_fetch_assign(change['uidAssignment'])
                if 'id' not in old_rec:
                    sys.stderr.write('WARNING: ignoring change %s\n' % change['uid'])
                    sys.stderr.write('on nonexistent assignment %s\n' % change['uidAssignment'])
                    if Options.debug:
                        pprint.pprint(change, stream=sys.stderr)
                        sys.stderr.write('\n')
                    continue

                # Generate metadata for this change
                change['isCarChange'] = 'uidvehicle' in change['affectedColumns']
                change['class']       = old_rec.get('classShort',
                        change['old'].get('vchclass',
                            change['new'].get('vchclass')))
                change['car']         = old_rec.get('vehicleNumber',
                        change['old'].get('vehicleNumber',
                            change['new'].get('vehicleNumber')))

                if 'firstName' in old_rec or 'lastName' in old_rec:
                    change['driver'] = ' '.join((
                        old_rec.get('firstName', ''),
                        old_rec.get('lastName', '')
                        )).strip()
                else:
                    change['driver'] = ' '.join((
                        change['old'].get('firstName', change['new'].get('firstName', '')),
                        change['old'].get('lastName', change['new'].get('lastName', ''))
                        )).strip()

                # Update the existing assignment in the database
                new_rec = deepcopy(old_rec)
                msr_add_member_info(new_rec, mem=mem)
                msr_add_attendee_info(new_rec, att=att)
                new_rec['vehicle_questions'] = asn['vehicle_questions'] if asn else {}
                for field in change['affectedColumns']:
                    if field == 'uidvehicle':
                        new_rec['vehicleuri'] = (att['memberuri']
                                + '/vehicles/' + change['new']['uidvehicle'])
                        continue
                    afield = msr_change_field_names.get(field, field)
                    if afield is not None:
                        new_rec[afield] = change['new'].get(field)
                db_store_assign(new_rec)

                # Detect differences in member and attendee fields
                for field in msr_member_only_fields + msr_attendee_only_fields:
                    if str(old_rec.get(field)) != str(new_rec.get(field)):
                        change['affectedColumns'].add(field)
                        change['old'][field] = old_rec.get(field)
                        change['new'][field] = new_rec.get(field)

                # Add event and vehicle questions to the change
                change['questions'] = qdiff(old_rec['questions'], new_rec['questions'])
                change['vehicle_questions'] = qdiff(
                        old_rec['vehicle_questions'], new_rec['vehicle_questions'])

                # Detect differences in custom fields
                build_custom_fields(new_rec)
                build_custom_fields(old_rec)
                for field in old_rec['CF'].keys() | new_rec['CF'].keys():
                    if str(old_rec['CF'].get(field)) != str(new_rec['CF'].get(field)):
                        change['affectedColumns'].add(field)
                        change['old'][field] = old_rec['CF'].get(field)
                        change['new'][field] = new_rec['CF'].get(field)

                change['isRelevant'] = (change['isCarChange'] or change['action'] == 'REST'
                        or bool( { msr_change_field_names.get(field, field)
                            for field in change['affectedColumns'] }
                            - Config['irrelevantFields'] ))

            elif change['action'] == 'DROP':
                ### Dropped or cancelled assignment
                old_rec = db_fetch_assign(change['uidAssignment'])

                # Generate metadata for this change
                change['isRelevant']  = True
                change['isCarChange'] = False
                change['class']       = old_rec.get('classShort',
                        change['old'].get('vchclass'))
                change['car']         = old_rec.get('vehicleNumber',
                        change['old'].get('vehicleNumber'))
                if 'firstName' in old_rec or 'lastName' in old_rec:
                    change['driver'] = ' '.join((
                        old_rec.get('firstName', ''),
                        old_rec.get('lastName', '')
                        )).strip()
                else:
                    change['driver'] = ' '.join((
                        change['old'].get('firstName', ''),
                        change['old'].get('lastName', '')
                        )).strip()

                # Update the existing assignment in the database
                old_rec['status'] = change['new']['attendeeStatus']
                change['questions'] = []
                change['vehicle_questions'] = []
                db_store_assign(old_rec)

            else:
                sys.stderr.write('WARNING: ignoring change %s %s\n'
                        % (change['action'], change['uid']))

            # Add this change to the database
            if Options.debug:
                sys.stderr.write('storing new change:\n')
                pprint.pprint(change, stream=sys.stderr)
                sys.stderr.write('\n')
            db_store_change(change, force=Options.force)


def show_change_results(recs):
    if Options.sort:
        recs = sorted(recs, key=lambda r:
                (r['class'], int(r['car']), r['car'].startswith('0'), r['xid']))
    else:
        recs = sorted(recs, key=lambda r: r['xid'])
    if Options.dump:
        pprint.pprint(recs)
        return

    if Options.long:
        fmt = '{xid:>4} {ts:%m/%d %H:%M} {_rel:3} {_cc:3} {_prt:3} {_done:4} {action:4} {_count:>3} {class:6.6} {car!s:>3} {driver:25} {authorName:25} {uid:36}'
    else:
        fmt = '{xid:>4} {ts:%m/%d %H:%M} {_cc:3} {_done:4} {action:4} {class:6.6} {car!s:>3} {driver:25}'
    nfmt = '     {field:20} {new!s:40}'
    ufmt = '     {field:20} {old!s:40} {new!s:40}'

    col_headers = {
            'uid'       : 'Change UID',
            'xid'       : 'Chg#',
            'ts'        : 'Date/Time',
            '_rel'      : 'Rel',
            '_cc'       : 'CC?',
            '_prt'      : 'Prt', 
            '_done'     : 'Done',
            'action'    : 'What',
            '_count'    : '#F',
            'class'     : 'Class',
            'car'       : 'No.',
            'driver'    : 'Driver',
            'authorName': 'Author',
            }
    print_header(fmt, col_headers)

    for data in recs:
        data['_rel'] = 'Yes' if data['isRelevant'] else 'No'
        data['_cc']  = 'Yes' if data['isCarChange'] else 'No'
        data['_prt'] = 'Yes' if data['printed'] else 'No'
        data['_done'] = (
                'A' if data['appliedA'] else '-' +
                'B' if data['appliedB'] else '-' +
                'C' if data['appliedC'] else '-' +
                'R' if data['appliedR'] else '-' )
        data['_count'] = len(data['affectedColumns'])
        if (Options.filter and not
                functools.reduce(lambda x,f: x and f[1].search(data[f[0]]),
                    Options.filter, True)):
            continue
        print(fmt.format(**data).rstrip())
        if Options.verbose and data['action'] == 'UPD':
            for field in sorted(data['affectedColumns']):
                print(ufmt.format(field=field,
                    old=data['old'][field], new=data['new'][field]).rstrip())
            if Options.event_questions:
                for q in sorted(data['questions'], key=lambda q: q['header']):
                    print(ufmt.format(field=q['header'],
                        old=q['old_answer'], new=q['new_answer']
                        ).rstrip())
            if Options.vehicle_questions:
                for q in sorted(data['vehicle_questions'], key=lambda q: q['header']):
                    print(ufmt.format(field=q['header'],
                        old=q['old_answer'], new=q['new_answer']
                        ).rstrip())
            print()
        elif Options.verbose and data['action'] != 'DROP':
            for field in sorted(data['affectedColumns']):
                print(nfmt.format(field=field,
                    old=data['old'][field], new=data['new'][field]).rstrip())
            if Options.event_questions:
                for q in sorted(data['questions'], key=lambda q: q['header']):
                    print(nfmt.format(field=q['header'],
                        old=q['old_answer'], new=q['new_answer']
                        ).rstrip())
            if Options.vehicle_questions:
                for q in sorted(data['vehicle_questions'], key=lambda q: q['header']):
                    print(nfmt.format(field=q['header'],
                        old=q['old_answer'], new=q['new_answer']
                        ).rstrip())
            print()


def do_changes():
    db_open()
    with DB:
        if Options.items:
            recs = [ db_fetch_change(item) for item in Options.items ]
        else:
            recs = db_fetch_all_changes()
    show_change_results(recs)


def do_dump_changes():
    dumpobj(msr_get_changes(cleanup=False))

def do_help(ap):
    if (Options.subcommand is not None):
        ap.parse_args([Options.subcommand, '--help'])
    else:
        ap.print_help()
    ap.exit()


def process_args():
    global Options
    ap = argparse.ArgumentParser(usage='%(prog)s [options] command [args...]',
            fromfile_prefix_chars='@')
    sp = ap.add_subparsers(title='subcommands', metavar=None)
    ap._optionals.title = 'Options'
    
    ap.add_argument('-d', '--debug', action='store_true',
            help='Enable debugging')
    ap.add_argument('-C', '--config',     help='Config file')
    ap.add_argument('-D', '--database',   help='Database file')
    ap.add_argument('--server', help='MotorsportReg API server')
    ap.add_argument('-U', '--userid',     help='MotorsportReg username')
    ap.add_argument('-P', '--password',   help='MotorsportReg password')
    ap.add_argument(      '--pwfile',     help='File containing MotorsportReg password')
    ap.add_argument('-O', '--org-id',     help='Organization ID')
    ap.add_argument('-E', '--event-id',   help='Event ID')
    ap.add_argument('-S', '--segment-id', help='Segment ID')
    ap.add_argument('--timezone', '--tz', type=tz.gettz, help='Timezone for dates')
    ap.add_argument('--attendee-data', type=argparse.FileType(),
            help='Prefetched attendee data file (for debug)')
    ap.add_argument('--assign-data', type=argparse.FileType(),
            help='Prefetched assignment data file (for debug)')
    ap.add_argument('--member-data', type=argparse.FileType(),
            help='Prefetched member data file (for debug)')
    ap.add_argument('--change-data', action='append', type=argparse.FileType(),
            help='Prefetched change data file (for debug)')

    p = sp.add_parser('help', help='Show help message or subcommand help')
    p.add_argument('subcommand', nargs='?', help='Subcommand to show help for')
    p.set_defaults(_func = do_help)
    p.set_defaults(_args = (ap,))

    p = sp.add_parser('events', help='List available events from MSR')
    p.add_argument('--archive', action='store_true', help='Show old events')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-x', '--dump', action='store_true', help='Dump raw data')
    p.set_defaults(_func = do_events)
    p.set_defaults(_required = opts_msr_reqd)

    p = sp.add_parser('segments', help='List event segments')
    p.add_argument('-v', '--verbose', action='store_true',
            help='Show detailed group info')
    p.add_argument('-x', '--dump', action='store_true', help='Dump raw data')
    p.set_defaults(_func = do_segments)
    p.set_defaults(_required = opts_msr_reqd + ('event-id',))

    p = sp.add_parser('members', help='List members')
    p.add_argument('items', nargs=argparse.REMAINDER, help='Member UIDs to dump')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-q', '--questions', action='store_true', help='Include questions')
    p.add_argument('-x', '--dump', action='store_true', help='Dump raw data')
    p.set_defaults(_func = do_members)
    p.set_defaults(_required = opts_msr_reqd)

    p = sp.add_parser('attendees', help='List attendees')
    p.add_argument('items', nargs=argparse.REMAINDER, help='Attendee IDs to dump')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-q', '--questions', action='store_true', help='Include questions')
    p.add_argument('--raw-dates', action='store_true', help="Don't convert dates")
    p.add_argument('-x', '--dump', action='store_true', help='Dump raw data')
    p.set_defaults(_func = do_attendees)
    p.set_defaults(_required = opts_msr_reqd + ('event-id',))

    p = sp.add_parser('assigns', help='List assignments')
    p.add_argument('items', nargs=argparse.REMAINDER, help='Assignment IDs to dump')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-s', '--sort', action='store_true', help='Sort by class, no')
    p.add_argument('-f', '--filter', action='append', help='Filter field:pattern',
            type=lambda s: (lambda f: (f[0], re.compile(f[1]))) (s.split(':', 1)+['']))
    p.add_argument('-v', '--verbose', action='store_true', help='Show all fields')
    p.add_argument('-q', '--questions',   action='store_true', help='Include all questions')
    p.add_argument('--event-questions',   action='store_true', help='Include event questions')
    p.add_argument('--vehicle-questions', action='store_true', help='Include vehicle questions')
    p.add_argument('--custom-fields',     action='store_true', help='Include custom fields')
    p.add_argument('-c', '--csv', action='store_true', help='Export CSV')
    p.add_argument('--tsv', action='store_true', help='Export tab-separated values')
    p.add_argument('--csv-format', help='CSV/TSV file format name')
    p.add_argument('--raw-dates', action='store_true', help="Don't convert dates")
    p.add_argument('-x', '--dump', action='store_true', help='Show raw data')
    p.set_defaults(_func = do_assigns)
    p.set_defaults(_required = opts_msr_reqd + ('event-id',))

    p = sp.add_parser('download', help='Download entry data to database')
    p.set_defaults(_func = do_download)
    p.set_defaults(_required = opts_msr_reqd + ('event-id','segment-id','database'))

    p = sp.add_parser('entries', help='List downloaded entries')
    p.add_argument('items', nargs=argparse.REMAINDER, help='Assignment IDs to dump')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-s', '--sort', action='store_true', help='Sort by class, no')
    p.add_argument('-f', '--filter', action='append', help='Filter field:pattern',
            type=lambda s: (lambda f: (f[0], re.compile(f[1]))) (s.split(':', 1)+['']))
    p.add_argument('-v', '--verbose', action='store_true', help='Show all fields')
    p.add_argument('-q', '--questions',   action='store_true', help='Include all questions')
    p.add_argument('--event-questions',   action='store_true', help='Include event questions')
    p.add_argument('--vehicle-questions', action='store_true', help='Include vehicle questions')
    p.add_argument('--custom-fields',     action='store_true', help='Include custom fields')
    p.add_argument('-c', '--csv', action='store_true', help='Export CSV')
    p.add_argument('--tsv', action='store_true', help='Export tab-separated values')
    p.add_argument('--csv-format', help='CSV/TSV file format name')
    p.add_argument('--raw-dates', action='store_true', help="Don't convert dates")
    p.add_argument('-x', '--dump', action='store_true', help='Show raw data')
    p.set_defaults(_func = do_entries)
    p.set_defaults(_required = ('database',))

    p = sp.add_parser('changes', help='List changes')
    p.add_argument('items', nargs=argparse.REMAINDER, help='Change IDs to dump')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-s', '--sort', action='store_true', help='Sort by class, no')
    p.add_argument('-f', '--filter', action='append', help='Filter field:pattern',
            type=lambda s: (lambda f: (f[0], re.compile(f[1]))) (s.split(':', 1)+['']))
    p.add_argument('-v', '--verbose', action='store_true', help='Show changed fields')
    p.add_argument('-q', '--questions',   action='store_true', help='Include all questions')
    p.add_argument('--event-questions',   action='store_true', help='Include event questions')
    p.add_argument('--vehicle-questions', action='store_true', help='Include vehicle questions')
    p.add_argument('-x', '--dump', action='store_true', help='Show raw data')
    p.set_defaults(_func = do_changes)
    p.set_defaults(_required = ('database',))

    p = sp.add_parser('dump_changes', help='Dump raw change data')
    p.add_argument('-t', '--since', type=parse_ts, help='Start time')
    p.set_defaults(_func = do_dump_changes)
    p.set_defaults(_required = opts_msr_reqd + ('event-id','segment-id'))

    p = sp.add_parser('update', help='Fetch changes and update database')
    p.add_argument('-t', '--since', type=parse_ts, help='Start time')
    p.add_argument('-f', '--force', action='store_true', help='Overwrite existing changes')
    p.set_defaults(_func = do_update)
    p.set_defaults(_required = opts_msr_reqd + ('event-id','segment-id','database'))

    Options = ap.parse_args()
    if not hasattr(Options, '_func'):
        ap.error('Missing subcommand')
    load_config()

    required = set(getattr(Options, '_required', ()))
    missing = [ x for x in required if getattr(Options, x.replace('-', '_'), None) is None ]
    if missing:
        for x in missing: sys.stderr.write("--%s is required\n" % x)
        ap.print_usage(file=sys.stderr)
        ap.exit(status=2)
    if getattr(Options, 'questions', False) and hasattr(Options, 'event_questions'):
        Options.event_questions = True
    if getattr(Options, 'questions', False) and hasattr(Options, 'vehicle_questions'):
        Options.vehicle_questions = True


    Options._func(*getattr(Options, '_args', ()))

process_args()

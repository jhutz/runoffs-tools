#!/usr/bin/env python3

import os
import sys
import collections
import itertools
from datetime import datetime, timezone
from dateutil import parser as dateutil_parser
import re
import argparse
import configparser
import requests
import json

# These command-line options can be set in the config file
opts_from_config = ('server', 'userid', 'password', 'pwfile',
            'org-id', 'event-id', 'segment-id')

# Default values for some options.
# Only needed for options that appear in opts_from_config
opts_defaults = { 'server' : 'api.motorsportreg.com' }

# Required options for anything that connects to MSR
opts_msr_reqd = ('server', 'userid', 'password', 'org-id' )

msr_attendee_params = { 'fields' : 'questions' }
msr_assign_params = { 'fields' : 'vehicle_questions' }

def load_config():
    """Load the config file, if any, and provide default values for options."""

    global Config
    Config = {}
    if Options.config is None:
        if 'HOME' in os.environ:
            def_cfg = os.path.join(os.environ['HOME'], '.msrmon')
        else:
            def_cfg = '.msrmon'
        if os.path.exists(def_cfg):
            Options.config = def_cfg
    if Options.config is not None:
        cp = configparser.ConfigParser()
        with open(Options.config) as lines:
            cp.read_file(itertools.chain(("[top]",), lines))
        Config = cp['top']

    for key in opts_from_config:
        okey = key.replace('-','_')
        if key in Config and getattr(Options, okey, None) is None:
            setattr(Options, okey, Config[key])
    for key in opts_defaults.keys():
        if getattr(Options, key, None) is None:
            setattr(Options, key, opts_defaults[key])
    if Options.password is None and Options.pwfile is not None:
        with open(Options.pwfile) as pwfile:
            Options.password = pwfile.readline()

def parse_ts(timestr):
    if re.match('^[0-9]+$', timestr):
        return datetime.fromtimestamp(int(timestr), timezone.utc)
    else:
        return dateutil_parser.parse(timestr,
                default=datetime.now(timezone.utc).replace(
                    hour=0, minute=0, second=0, microsecond=0))

def dumpobj(obj):
    print(json.dumps(obj, sort_keys=True, indent=4))

def print_header(fmt, cols):
    def dash(x):
        if isinstance(x, collections.abc.Mapping):
            return { k : dash(v) for k, v in x.items() }
        else:
            return '='
    if Options.dump: return
    print(fmt.format(**cols).rstrip())
    print(fmt.replace(':',':=<').format(**dash(cols)))

def msr_session():
    global MSR
    if 'MSR' not in globals():
        MSR = requests.Session()
        MSR.auth = (Options.userid, Options.password)
        MSR.headers.update({ 'X-Organization-Id' : Options.org_id })
    return MSR

def msr_get(query, params={}):
    sess = msr_session()
    r = sess.get('https://%s/rest/%s.json' % (Options.server, query), params = params)
    r.raise_for_status()
    return r.json()

def msr_get_attendee(item):
    if Options.attendee_data is not None:
        if 'Fake_Attendees' not in globals():
            msr_get_attendee_list()
        return Fake_Attendees.get(item, None)
    j = msr_get('events/%s/attendees/%s' % (Options.event_id, item),
            params = msr_attendee_params)
    try: rec = j['response']['attendees'][0]
    except IndexError: return None
    return rec

def msr_get_attendee_list():
    global Fake_Attendees
    if 'Fake_Attendees' in globals():
        return Fake_Attendees.values()
    elif Options.attendee_data is not None:
        j = json.load(Options.attendee_data)
        Fake_Attendees = collections.OrderedDict( [ (x['id'], x) for x in j ] )
        return Fake_Attendees.values()
    j = msr_get('events/%s/attendees' % Options.event_id,
            params = msr_attendee_params)
    return j['response']['attendees']

def msr_get_assign(item):
    if Options.assign_data is not None:
        if 'Fake_Assigns' not in globals():
            msr_get_attendee_list()
        return Fake_Assigns.get(item, None)
    j = msr_get('events/%s/assignments/%s' % (Options.event_id, item),
            msr_assign_params)
    try: rec = j['response']['assignments'][0]
    except IndexError: return None
    return rec

def msr_get_assign_list():
    global Fake_Assigns
    if 'Fake_Assigns' in globals():
        return Fake_Assigns.values()
    elif Options.assign_data is not None:
        j = json.load(Options.assign_data)
        Fake_Assigns = collections.OrderedDict( [ (x['id'], x) for x in j ] )
        return Fake_Assigns.values()
    j = msr_get('events/%s/segments/%s/assignments' %
            (Options.event_id, Options.segment_id),
            msr_assign_params)
    return j['response']['assignments']

def msr_get_changes():
    params = { 'segments' : Options.segment_id }
    # XXX look up last known change in database
    if Options.since is not None:
        params['since'] = Options.since.strftime('%Y-%m-%d %H:%M:%S.%f')
    j = msr_get('events/%s/feeds/timing' % Options.event_id, params=params)
    if not j['success']:
        sys.stderr.write('MSR API request failed:')
        for e in j['errors']:
            sys.stderr.write(e)
        sys.exit(1)
    return j['data']


def do_list_events():
    j = msr_get('calendars/organization/%s' % Options.org_id,
            params = { 'archive' : 'true' } if Options.archive else {})
    if Options.dump:
        dumpobj(j)
        return
    if Options.long:
        fmt = '{id:35} {name:30.30} {start:10} {venue[name]:10}'
    else:
        fmt = '{id:35} {name:30}'
    col_headers = {
            'id'    : 'Event ID',
            'name'  : 'Event Name',
            'start' : 'Date',
            'venue' : { 'name' : 'Venue' },
            }
    print_header(fmt, col_headers)
    for rec in j['response']['events']:
        print(fmt.format(**rec).rstrip())


def do_list_segments():
    j = msr_get('events/%s/segments' % Options.event_id)
    if Options.dump:
        dumpobj(j)
        return
    fmt = '{id:35} {name:30}'
    col_headers = {
            'id'    : 'Segment ID',
            'name'  : 'Segment Name',
            }
    print_header(fmt, col_headers)
    for rec in j['response']['segments']:
        print(fmt.format(**rec).rstrip())
        if Options.verbose:
            class_map = { x['id'] : x['shortName'] for x in seg['classes'] }
            for grp in sorted(seg['groups'], key=lambda x: x['shortName']):
                classes = [ class_map[x['classId']]
                        for x in seg['classToGroupMaps'] if x['groupId'] == grp['id'] ]
                if len(classes) > 0:
                    print('    ', grp['shortName'], '('+', '.join(sorted(classes))+')')
                else:
                    print('    ', grp['shortName'])


def do_list_attendees():
    if Options.items is not None and len(Options.items) > 0:
        recs = [ msr_get_attendee(item) for item in Options.items ]
    else:
        recs = msr_get_attendee_list()

    if Options.dump:
        dumpobj(recs)
        return
    if Options.long:
        fmt = '{memberId!s:8} {_fullName:30.30} {_homeTown:25.25} {email:30.30} {registered:19} {lastUpdate:19}'
    else:
        fmt = '{memberId!s:8} {lastName:35} {firstName:25} {registered/date:10}'
    col_headers = {
            'memberId'        : 'Member #',
            'firstName'       : 'First Name',
            'lastName'        : 'Last Name',
            '_fullName'       : 'Name',
            '_homeTown'       : 'Home Town',
            'email'           : 'Email Address',
            'registered'      : 'Registration Date',
            'registered/date' : 'Registered',
            'lastUpdate'      : 'Last Updated',
            'lastUpdate/date' : 'Last Updated',
            }

    print_header(fmt, col_headers)
    for rec in recs:
        reg = parse_ts(rec['registered'])
        upd = parse_ts(rec['lastUpdate'])
        data = rec.copy()
        data['_fullName'] = ' '.join((data['firstName'], data['lastName']),)
        data['_homeTown'] = ' '.join((data['city'], data['region']),)
        data['registered/date'] = reg.astimezone().strftime('%Y-%m-%d')
        data['lastUpdate/date'] = upd.astimezone().strftime('%Y-%m-%d')

        print(fmt.format(**data).rstrip())
        if Options.questions:
            for q in sorted([ (q['header'], q['answer']) for q in data['questions'] ]):
                print('  {0:35} {1}'.format(*q))


def do_list_assigns():
    if Options.items is not None and len(Options.items) > 0:
        recs = [ msr_get_assign(item) for item in Options.items ]
    else:
        recs = msr_get_assign_list()

    if Options.dump:
        dumpobj(recs)
        return
    if Options.long:
        fmt = '{vehicleNumber:3} {classShort:6} {_fullName:30.30} {memberId!s:8} {transponder!s:8} {year:4} {make:20.20} {model:20.20} {color:15.15} {sponsor:20}'
    else:
        fmt = '{vehicleNumber:3} {classShort:6} {_fullName:30.30} {transponder!s:8} {year:4} {_MM:22}'
    col_headers = {
            'vehicleNumber'   : 'No.',
            'classShort'      : 'Class',
            '_fullName'       : 'Name',
            'transponder'     : 'Tx #',
            'year'            : 'Year',
            '_MM'             : 'Make/Model',
            'make'            : 'Make',
            'model'           : 'Model',
            'color'           : 'Color',
            'memberId'        : 'Member #',
            '_homeTown'       : 'Home Town',
            'sponsor'         : 'Sponsor',
            }

    print_header(fmt, col_headers)
    for rec in recs:
        data = rec.copy()
        data['_fullName'] = ' '.join((data['firstName'], data['lastName']),)
        data['_homeTown'] = ' '.join((data['city'], data['region']),)
        data['_MM'] = ' '.join((data['make'], data['model']),)

        print(fmt.format(**data).rstrip())
        if Options.questions:
            for q in sorted([ (q['header'], q['answer']) for q in data['vehicle_questions'] ]):
                print('  {0:35} {1}'.format(*q))


def do_update():
    for rec in msr_get_changes():
        # Fetch assign(vehicle) and attendee(entry) questions
        # Apply special-case field mappings

        # BEGIN TRANSACTION
        # Ensure assign UID and all question UIDs are in database
        # This is a separate transaction so it commits even if below aborts
        # END TRANSACTION

        # BEGIN TRANSACTION
        # Compare questions against DB; compute diffs; update DB
        # Is change in database already? If so:
        # - With --force, blow away existing field diffs
        # - Otherwise, if there are no question diffs, move on to next change
        # - Otherwise, cons up a fake change to record the question diffs
        # Derive custom field values from questions
        # Derive old/new values for composite fields if any component changed
        # Figure out if this is an "interesting" change
        # Add/update change metadata
        # Add field diffs

        pass


def do_dump_changes():
    dumpobj(msr_get_changes())

def do_help(ap):
    if (Options.subcommand is not None):
        ap.parse_args([Options.subcommand, '--help'])
    else:
        ap.print_help()
    ap.exit()


def process_args():
    global Options
    ap = argparse.ArgumentParser(usage='%(prog)s [options] command [args...]')
    sp = ap.add_subparsers(title='subcommands', metavar=None)
    ap._optionals.title = 'Options'
    
    ap.add_argument('-d', '--debug', action='store_true',
            help='Enable debugging')
    ap.add_argument('-v', '--verbose', action='store_true',
            help='Enable verbose output')
    ap.add_argument('-c', '--config',     help='Config file')
    ap.add_argument('--server', help='MotorsportReg API server')
    ap.add_argument('-U', '--userid',     help='MotorsportReg username')
    ap.add_argument('-P', '--password',   help='MotorsportReg password')
    ap.add_argument(      '--pwfile',     help='File containing MotorsportReg password')
    ap.add_argument('-O', '--org-id',     help='Organization ID')
    ap.add_argument('-E', '--event-id',   help='Event ID')
    ap.add_argument('-S', '--segment-id', help='Segment ID')
    ap.add_argument('--attendee-data', type=argparse.FileType(),
            help='Prefetched attendee data file (for debug)')
    ap.add_argument('--assign-data', type=argparse.FileType(),
            help='Prefetched assignment data file (for debug)')

    p = sp.add_parser('help', help='Show help message or subcommand help')
    p.add_argument('subcommand', nargs='?', help='Subcommand to show help for')
    p.set_defaults(_func = do_help)
    p.set_defaults(_args = (ap,))

    p = sp.add_parser('list_events', help='List available events from MSR')
    p.add_argument('--archive', action='store_true', help='Show old events')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-x', '--dump', action='store_true', help='Dump raw data')
    p.set_defaults(_func = do_list_events)
    p.set_defaults(_required = opts_msr_reqd)

    p = sp.add_parser('list_segments', help='List event segments')
    p.add_argument('-x', '--dump', action='store_true', help='Dump raw data')
    p.set_defaults(_func = do_list_segments)
    p.set_defaults(_required = opts_msr_reqd + ('event-id',))

    p = sp.add_parser('list_attendees', help='List attendees')
    p.add_argument('items', nargs=argparse.REMAINDER, help='Attendee IDs to dump')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-q', '--questions', action='store_true', help='Include questions')
    p.add_argument('-x', '--dump', action='store_true', help='Dump raw data')
    p.set_defaults(_func = do_list_attendees)
    p.set_defaults(_required = opts_msr_reqd + ('event-id',))

    p = sp.add_parser('list_assigns', help='List assignments')
    p.add_argument('items', nargs=argparse.REMAINDER, help='Assignment IDs to dump')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-q', '--questions', action='store_true', help='Include questions')
    p.add_argument('-x', '--dump', action='store_true', help='Show raw data')
    p.set_defaults(_func = do_list_assigns)
    p.set_defaults(_required = opts_msr_reqd + ('event-id',))

    p = sp.add_parser('dump_changes', help='Dump raw change data')
    p.add_argument('-t', '--since', type=parse_ts, help='Start time')
    p.set_defaults(_func = do_dump_changes)
    p.set_defaults(_required = opts_msr_reqd + ('event-id','segment-id'))

    Options = ap.parse_args()
    if not hasattr(Options, '_func'):
        ap.error('Missing subcommand')
    load_config()

    required = set(getattr(Options, '_required', ()))
    missing = [ x for x in required if getattr(Options, x.replace('-', '_'), None) is None ]
    if len(missing) > 0:
        for x in missing: sys.stderr.write("--%s is required\n" % x)
        ap.print_usage(file=sys.stderr)
        ap.exit(status=2)

    Options._func(*getattr(Options, '_args', ()))

process_args()

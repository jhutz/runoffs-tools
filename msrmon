#!/usr/bin/env python3

import os
import sys
import collections
import itertools
import pprint
from copy import deepcopy
from datetime import datetime, timezone
from dateutil import parser as dateutil_parser
import re
import argparse
import requests
import sqlite3
import csv
import json
import yaml

# These command-line options can be set in the config file
opts_from_config = ('database', 'server', 'userid', 'password', 'pwfile',
            'org-id', 'event-id', 'segment-id')

# Default values for some options.
# Only needed for options that appear in opts_from_config
opts_defaults = { 'server' : 'api.motorsportreg.com' }

# Default configuration
config_defaults = {
    'csvFields' : [
        { 'segment'        : 'Segment Name' },
        { 'vehicleNumber'  : 'No.' },
        { 'classShort'     : 'Class' },
        { 'groupShort'     : 'Group' },
        { 'lastName'       : 'Last Name' },
        { 'firstName'      : 'First Name' },
        { 'memberId'       : 'Member #' },
        { 'xxx-ROR'        : 'Region of Record Abbreviation' },
        { '_homeTown'      : 'City/State' },
        { '_MM'            : 'Vehicle Year/Make/Model' },
        { 'color'          : 'Color' },
        { 'transponder'    : 'Transponder ID' },
        { 'sponsor'        : 'Sponsor' },
        { 'registered'     : 'Registration date' },
        { 'xxx-UID'        : 'Unique ID' },
        ],
    'csvEventQuestions' : [],
    'csvVehicleQuestions' : [],
}


# Required options for anything that connects to MSR
opts_msr_reqd = ('server', 'userid', 'password', 'org-id' )

# Query parameters for some MSR API calls
msr_attendee_params = { 'fields' : 'questions' }
msr_assign_params = { 'fields' : 'vehicle_questions' }

# Relevant attendee fields not included in assignment:
msr_attendee_only_fields = [ 'email', 'registered', 'lastUpdate',
        'emergencyContact', 'emergencyPhone', 'questions' ]


def load_config():
    """Load the config file, if any, and provide default values for options."""

    global Config
    Config = {}
    if Options.config is None:
        if 'HOME' in os.environ:
            def_cfg = os.path.join(os.environ['HOME'], '.msrmon')
        else:
            def_cfg = '.msrmon'
        if os.path.exists(def_cfg):
            Options.config = def_cfg
    if Options.config is not None:
        with open(Options.config) as cfg_file:
            Config = yaml.safe_load(cfg_file)
    for (k,v) in config_defaults.items():
        if k not in Config:
            Config[k] = v

    for key in opts_from_config:
        okey = key.replace('-','_')
        if key in Config and getattr(Options, okey, None) is None:
            setattr(Options, okey, Config[key])
    for key in opts_defaults.keys():
        if getattr(Options, key, None) is None:
            setattr(Options, key, opts_defaults[key])
    if Options.password is None and Options.pwfile is not None:
        with open(Options.pwfile) as pwfile:
            Options.password = pwfile.readline()

def is_uid(s):
    if not isinstance(s, str): return False
    if re.fullmatch('(?i)[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{16}$', s):
        return True
    return False

def parse_ts(timestr):
    if re.match('^[0-9]+$', timestr):
        return datetime.fromtimestamp(int(timestr), timezone.utc)
    else:
        return dateutil_parser.parse(timestr,
                default=datetime.now(timezone.utc).replace(
                    hour=0, minute=0, second=0, microsecond=0))

def dumpobj(obj):
    print(json.dumps(obj, sort_keys=True, indent=4))

def print_header(fmt, cols):
    def dash(x):
        if isinstance(x, collections.abc.Mapping):
            return { k : dash(v) for k, v in x.items() }
        else:
            return '='
    if Options.dump: return
    print(fmt.format(**cols).rstrip())
    print(re.sub(r':[^}\d]*(\d+)[^}]*}', r':=<\1}', fmt).format(**dash(cols)))


def db_open():
    global DB
    if 'DB' in globals(): return
    DB = sqlite3.connect(Options.database, detect_types=sqlite3.PARSE_DECLTYPES)
    DB.row_factory = sqlite3.Row
    DB.executescript("""
create table if not exists assignments (
  aid           integer primary key,
  uid           text unique not null
);

create table if not exists assign_data (
  aid           integer not null references assignments,
  field         text not null,
  value         text,
  primary key (aid, field)
);

create table if not exists questions (
  qid           integer primary key,
  uid           text unique not null,
  kind          text not null,
  header        text not null,
  descr         text
);

create table if not exists answers (
  aid           integer not null references assignments,
  qid           integer not null references questions,
  answer        text,
  primary key (aid,qid)
);

create table if not exists changes (
  xid           integer primary key,
  uid           text unique not null,
  aid           integer not null references assignments,
  timestamp     timestamp,
  authorName    text,
  authorEmail   text,
  class         text,
  car           text,
  driver        text,
  isCarChange   int(1),
  isRelevant    int(1),
  printed       int(1) not null default 0,
  appliedA      int(1) not null default 0,
  appliedB      int(1) not null default 0,
  appliedC      int(1) not null default 0,
  appliedR      int(1) not null default 0
);

create table if not exists change_data (
  xid           integer not null references changes,
  field         text not null,
  old_value     text,
  new_value     text,
  primary key (xid, field)
);
""")

QID_Cache = {}

def db_cache_qids(kind, info):
    needed = set([ x['id'] for x in info ]) - set(QID_Cache.keys())
    if needed:
        QID_Cache.update([ (x['uid'], x['qid'])
            for x in DB.execute('select uid, qid from questions') ])
        needed.difference_update(QID_Cache.keys())
    if needed:
        DB.executemany('''
            insert into questions (uid, header, descr,kind)
            values (:id,:header,:text,:kind)
            ''', [ dict(x, kind=kind) for x in info if x['id'] in needed ])
        QID_Cache.update([ (x['uid'], x['qid'])
            for x in DB.execute('select uid, qid from questions') ])

def db_store_answers(aid, kind, info):
    db_cache_qids(kind, info)
    DB.executemany('insert into answers (aid, qid, answer) values (?,?,?)',
            [ (aid, QID_Cache[x['id']], x['answer']) for x in info ])

def db_store_assign(rec):
    c = DB.execute('select aid from assignments where uid=?', (rec['id'],))
    r = c.fetchall()
    if r:
        aid = r[0]['aid']
        DB.execute('delete from assign_data where aid=?', (aid,))
        DB.execute('delete from answers where aid=?', (aid,))
    else:
        c = DB.execute('insert into assignments (uid) values (?)', (rec['id'],))
        aid = c.lastrowid
    DB.executemany('insert into assign_data (aid, field, value) values (?,?,?)',
            [ (aid, k, v) for k, v in rec.items() if not isinstance(v, (list, dict)) ])
    if 'questions' in rec:
        db_store_answers(aid, 'E', rec['questions'])
    if 'vehicle_questions' in rec:
        db_store_answers(aid, 'V', rec['vehicle_questions'])

def db_fetch_answers(item, kind):
    c = DB.execute('''
        select questions.uid as id, header, descr as text, answer
        from answers join assignments using (aid) join questions using (qid)
        where assignments.uid=? and questions.kind=?
        ''', (item, kind))
    return [ dict(row) for row in c ]

def db_fetch_assign(item):
    c = DB.execute('''
        select field,value
        from assignments join assign_data using (aid)
        where assignments.uid=?
        ''', (item,))
    rec = { x['field'] : x['value'] for x in c }
    rec['questions'] = db_fetch_answers(item, 'E')
    rec['vehicle_questions'] = db_fetch_answers(item, 'V')
    return rec

def db_fetch_all_assigns():
    return [ db_fetch_assign(item[0])
            for item in DB.execute('select uid from assignments') ]

def msr_session():
    global MSR
    if 'MSR' not in globals():
        MSR = requests.Session()
        MSR.auth = (Options.userid, Options.password)
        MSR.headers.update({ 'X-Organization-Id' : Options.org_id })
    return MSR

def msr_get(query, params={}):
    sess = msr_session()
    if Options.debug:
        sys.stderr.write('msr_get(%s)\n' % query)
        pprint.pprint(params, stream=sys.stderr)
    r = sess.get('https://%s/rest/%s.json' % (Options.server, query), params = params)
    r.raise_for_status()
    return r.json()


def _msr_load_fake_attendees():
    global Fake_Attendees
    if 'Fake_Attendees' not in globals():
        if Options.debug:
            sys.stderr.write('Loading fake attendees from %s\n' % Options.attendee_data)
        j = json.load(Options.attendee_data)
        Fake_Attendees = collections.OrderedDict( [ (x['id'], x) for x in j ] )
        if Options.debug:
            sys.stderr.write('Loaded %d fake attendees\n' % len(Fake_Attendees))

def msr_get_attendee(item):
    if Options.debug: sys.stderr.write('GET ATTENDEE %s\n' % item)
    if Options.attendee_data is not None:
        _msr_load_fake_attendees()
        return deepcopy(Fake_Attendees.get(item, None))
    j = msr_get('events/%s/attendees/%s' % (Options.event_id, item),
            params = msr_attendee_params)
    try: rec = j['response']['attendees'][0]
    except IndexError: return None
    return rec

def msr_get_attendee_list():
    if Options.attendee_data is not None:
        _msr_load_fake_attendees()
        return [ deepcopy(x) for x in Fake_Attendees.values() ]
    j = msr_get('events/%s/attendees' % Options.event_id,
            params = msr_attendee_params)
    return j['response']['attendees']

def msr_get_attendee_dict():
    if Options.attendee_data is not None:
        _msr_load_fake_attendees()
        return { k : deepcopy(v) for k,v in Fake_Attendees.items() }
    j = msr_get('events/%s/attendees' % Options.event_id,
            params = msr_attendee_params)
    return { x['id'] : x for x in j['response']['attendees'] }


def _msr_load_fake_assigns():
    global Fake_Assigns
    if 'Fake_Assigns' not in globals():
        if Options.debug:
            sys.stderr.write('Loading fake assignments from %s\n' % Options.assign_data)
        j = json.load(Options.assign_data)
        Fake_Assigns = collections.OrderedDict( [ (x['id'], x) for x in j ] )
        if Options.debug:
            sys.stderr.write('Loaded %d fake assignments\n' % len(Fake_Assigns))

def msr_get_assign(item):
    if Options.debug: sys.stderr.write('GET ASSIGN %s\n' % item)
    if Options.assign_data is not None:
        _msr_load_fake_assigns()
        return deepcopy(Fake_Assigns.get(item, None))
    j = msr_get('events/%s/assignments/%s' % (Options.event_id, item),
            msr_assign_params)
    try: rec = j['response']['assignments'][0]
    except IndexError: return None
    return rec

def msr_get_assign_list():
    if Options.assign_data is not None:
        _msr_load_fake_assigns()
        return [ deepcopy(x) for x in Fake_Assigns.values() ]
    j = msr_get('events/%s/segments/%s/assignments' %
            (Options.event_id, Options.segment_id),
            msr_assign_params)
    return j['response']['assignments']


def msr_add_attendee_info(rec, att_cache=None):
    """Augment an assignment by adding data from the attendee record."""

    id = rec['attendeeId']
    if att_cache is None:
        att = msr_get_attendee(id)
    elif id not in att_cache:
        att = att_cache[id] = msr_get_attendee(id)
    else:
        att = att_cache[id]
    rec.update([ (k, att[k]) for k in msr_attendee_only_fields])

def msr_get_changes():
    params = { 'segments' : Options.segment_id }
    # XXX look up last known change in database
    if Options.since is not None:
        params['since'] = Options.since.strftime('%Y-%m-%d %H:%M:%S.%f')
    j = msr_get('events/%s/feeds/timing' % Options.event_id, params=params)
    if not j['success']:
        sys.stderr.write('MSR API request failed:')
        for e in j['errors']:
            sys.stderr.write(e)
        sys.exit(1)
    return j['data']


def eval_custom_field(rec, Q, name, defn):
    postproc = []
    if Options.debug:
        sys.stderr.write('eval_custom_field(%s):\n' % name)
        pprint.pprint(defn, stream=sys.stderr)
    if isinstance(defn, list):
        # Definition has modifiers
        (defn, *postproc) = defn
    if isinstance(defn, collections.abc.Mapping):
        if len(defn) != 1:
            raise ValueError("Choice mapping must have exactly one key")
        (ref, table) = next(iter(defn.items()))
        if not isinstance(table, collections.abc.Mapping):
            raise TypeError("Choice mapping table must be a mapping")
        if Options.debug: sys.stderr.write('  choice(%s(%s))\n' % (ref, rec.get(ref)))
        value = eval_custom_field(rec, Q, name + '+',
                table.get(rec.get(ref), table.get(None)))
    elif is_uid(defn):
        # Question UID; None if question is not present
        if Options.debug: sys.stderr.write('  question(%s)\n' % defn)
        value = Q.get(defn)
    elif isinstance(defn, str):
        # Format string
        if Options.debug: sys.stderr.write('  format(%s)\n' % defn)
        value = defn.format(**rec)
    else:
        # Other scalar values are used as-is
        if Options.debug: sys.stderr.write('  literal(%s)\n' % str(defn))
        value = defn
    if Options.debug: sys.stderr.write('  value is [%s]\n' % str(value))

    for op in postproc:
        if isinstance(op, collections.abc.Mapping):
            # Value remapping
            if Options.debug:
                sys.stderr.write('  remap value: %s\n' % pprint.pformat(op))
            nv = op.get(value, op.get(None, {}))
            if Options.debug:
                sys.stderr.write('     new defn: %s\n' % pprint.pformat(nv))
            if isinstance(nv, collections.abc.Mapping) and len(nv) == 0:
                # The empty mapping means "don't change it"
                continue
            value = eval_custom_field(rec, Q, name + '>', nv)
            if Options.debug:
                sys.stderr.write('    new value: [%s]\n' % str(value))
        elif isinstance(op, str):
            # Pattern splitting
            if Options.debug:
                sys.stderr.write('  split: %s\n' % op)
            m = re.search(op, value)
            if m:
                newf = m.groupdict()
                if Options.debug:
                    sys.stderr.write('  matched %d fields\n' % len(newf))
                    pprint.pprint(newf, stream=sys.stderr)
                rec.update(newf)
                rec['CF'].update(newf)
    if Options.debug: sys.stderr.write('\n')
    return value

def build_custom_fields(rec):
    if Options.debug:
        sys.stderr.write('build_custom_fields:\n')
        pprint.pprint(rec, stream=sys.stderr)
    rec['CF'] = {}
    if 'CustomFields' not in Config: return
    if not isinstance(Config['CustomFields'], collections.abc.Sequence):
        Config['CustomFields'] = [ Config['CustomFields'] ]

    Q = {}
    if 'questions' in rec:
        Q.update([ (q['id'], q['answer']) for q in rec['questions'] ])
    if 'vehicle_questions' in rec:
        Q.update([ (q['id'], q['answer']) for q in rec['vehicle_questions'] ])
    if Options.debug:
        pprint.pprint(Q, stream=sys.stderr)
    for cfset in Config['CustomFields']:
        for cf, defn in cfset.items():
            rec[cf] = rec['CF'][cf] = eval_custom_field(rec, Q, cf, defn)


def do_events():
    j = msr_get('calendars/organization/%s' % Options.org_id,
            params = { 'archive' : 'true' } if Options.archive else {})
    if Options.dump:
        dumpobj(j)
        return
    if Options.long:
        fmt = '{id:35} {name:30.30} {start:10} {venue[name]:10}'
    else:
        fmt = '{id:35} {name:30}'
    col_headers = {
            'id'    : 'Event ID',
            'name'  : 'Event Name',
            'start' : 'Date',
            'venue' : { 'name' : 'Venue' },
            }
    print_header(fmt, col_headers)
    for rec in j['response']['events']:
        print(fmt.format(**rec).rstrip())


def do_segments():
    j = msr_get('events/%s/segments' % Options.event_id)
    if Options.dump:
        dumpobj(j)
        return
    fmt = '{id:35} {name:30}'
    col_headers = {
            'id'    : 'Segment ID',
            'name'  : 'Segment Name',
            }
    print_header(fmt, col_headers)
    for rec in j['response']['segments']:
        print(fmt.format(**rec).rstrip())
        if Options.verbose:
            class_map = { x['id'] : x['shortName'] for x in seg['classes'] }
            for grp in sorted(seg['groups'], key=lambda x: x['shortName']):
                classes = [ class_map[x['classId']]
                        for x in seg['classToGroupMaps'] if x['groupId'] == grp['id'] ]
                if classes:
                    print('    ', grp['shortName'], '('+', '.join(sorted(classes))+')')
                else:
                    print('    ', grp['shortName'])


def do_attendees():
    if Options.items:
        recs = [ msr_get_attendee(item) for item in Options.items ]
    else:
        recs = msr_get_attendee_list()

    if Options.dump:
        dumpobj(recs)
        return
    if Options.long:
        fmt = '{memberId!s:8} {_fullName:30.30} {_homeTown:25.25} {email:30.30} {registered:19} {lastUpdate:19}'
    else:
        fmt = '{memberId!s:8} {_fullName:30.30} {registered/date:10}'
    col_headers = {
            'memberId'        : 'Member #',
            'firstName'       : 'First Name',
            'lastName'        : 'Last Name',
            '_fullName'       : 'Name',
            '_homeTown'       : 'Home Town',
            'email'           : 'Email Address',
            'registered'      : 'Registration Date',
            'registered/date' : 'Registered',
            'lastUpdate'      : 'Last Updated',
            'lastUpdate/date' : 'Last Updated',
            }

    print_header(fmt, col_headers)
    for data in recs:
        reg = parse_ts(data['registered'])
        upd = parse_ts(data['lastUpdate'])
        data['_fullName'] = ' '.join((str(data['firstName']), str(data['lastName'])),)
        data['_homeTown'] = ' '.join((str(data['city']),      str(data['region'])),)
        data['registered/date'] = reg.astimezone().strftime('%Y-%m-%d')
        data['lastUpdate/date'] = upd.astimezone().strftime('%Y-%m-%d')

        print(fmt.format(**data).rstrip())
        if Options.questions:
            for q in sorted([ (q['header'], q['answer']) for q in data['questions'] ]):
                print('  {0:35} {1}'.format(*q))


def show_assign_csv(recs, att_cache=None, fromdb=False):
    # Set up columns
    fields = []
    header = {}
    for field in Config['csvFields']:
        if not isinstance(field, dict):
            k = v = field
        elif len(field) != 1:
            raise ValueError("CSV field mapping must have exactly one key")
        else:
            (k,v) = next(iter(field.items()))
        fields.append(k)
        header[k] = v
    if Options.questions or Options.event_questions:
        # Add event question columns
        if fromdb:
            att_data = recs
        else:
            if att_cache is None: att_cache = {}
            if not att_cache:
                for id in [ rec['id'] for rec in recs ]:
                    att_cache[id] = msr_get_attendee(id)
            att_data = att_cache
        Q = { q['header'] : q['id'] for rec in att_data for q in rec['questions'] }
        header.update((v,k) for k,v in Q.items())
        fields.extend(Q.pop(f,f) for f in Config['csvEventQuestions'])
        header.update((f,f) for f in fields if f not in header)
        fields.extend(sorted(Q.values()))
    if Options.questions or Options.vehicle_questions:
        # Add vehicle question columns
        Q = { q['header'] : q['id'] for rec in recs for q in rec['vehicle_questions'] }
        header.update((v,k) for k,v in Q.items())
        fields.extend(Q.pop(f,f) for f in Config['csvVehicleQuestions'])
        header.update((f,f) for f in fields if f not in header)
        fields.extend(sorted(Q.values()))

    writer = csv.DictWriter(sys.stdout, fieldnames=fields,
            extrasaction='ignore', quoting=csv.QUOTE_ALL)
    writer.writerow(header)

    if Options.sort:
        recs = sorted(recs, key=lambda r: (r['classShort'], str(r['vehicleNumber'])))
    for data in recs:
        if not fromdb:
            msr_add_attendee_info(data, att_cache)
        build_custom_fields(data)
        data['_fullName'] = ' '.join((str(data['firstName']), str(data['lastName'])),)
        data['_homeTown'] = ' '.join((str(data['city']),      str(data['region'])),)
        data['_MM']       = ' '.join((str(data['make']),      str(data['model'])),)
        if 'questions' in data:
            data.update([ (q['id'], q['answer']) for q in data['questions'] ])
        if 'vehicle_questions' in data:
            data.update([ (q['id'], q['answer']) for q in data['vehicle_questions'] ])
        writer.writerow(data)


def show_assign_results(recs, att_cache=None, fromdb=False):
    if Options.dump:
        dumpobj(recs)
        return
    if Options.csv:
        show_assign_csv(recs, att_cache=att_cache, fromdb=fromdb)
        return

    if Options.long:
        fmt = '{vehicleNumber!s:>3} {classShort:6} {_fullName:30.30} {memberId!s:8} {transponder!s:8} {year:4} {make:20.20} {model:20.20} {color:15.15} {sponsor:20}'
    else:
        fmt = '{vehicleNumber!s:>3} {classShort:6} {_fullName:30.30} {transponder!s:8} {year:4} {_MM:22}'
    col_headers = {
            'vehicleNumber'   : 'No.',
            'classShort'      : 'Class',
            '_fullName'       : 'Name',
            'transponder'     : 'Tx #',
            'year'            : 'Year',
            '_MM'             : 'Make/Model',
            'make'            : 'Make',
            'model'           : 'Model',
            'color'           : 'Color',
            'memberId'        : 'Member #',
            '_homeTown'       : 'Home Town',
            'sponsor'         : 'Sponsor',
            }
    print_header(fmt, col_headers)

    if Options.sort:
        recs = sorted(recs, key=lambda r: (r['classShort'], str(r['vehicleNumber'])))
    for data in recs:
        if ((Options.questions or Options.event_questions or Options.custom_fields)
                and not fromdb):
            msr_add_attendee_info(data, att_cache)
        if Options.custom_fields:
            build_custom_fields(data)
        data['_fullName'] = ' '.join((str(data['firstName']), str(data['lastName'])),)
        data['_homeTown'] = ' '.join((str(data['city']),      str(data['region'])),)
        data['_MM']       = ' '.join((str(data['make']),      str(data['model'])),)

        print(fmt.format(**data).rstrip())
        if Options.questions or Options.event_questions:
            for q in sorted([ (q['header'], q['answer']) for q in data['questions'] ]):
                print('  EQ:{0:35} {1}'.format(*q))
        if Options.questions or Options.vehicle_questions:
            for q in sorted([ (q['header'], q['answer']) for q in data['vehicle_questions'] ]):
                print('  VQ:{0:35} {1}'.format(*q))
        if Options.custom_fields:
            for q in sorted(data['CF'].items()):
                print('  CF:{0:35} {1}'.format(*q))

def do_assigns():
    att_cache = {}
    if Options.items:
        recs = [ msr_get_assign(item) for item in Options.items ]
    else:
        recs = msr_get_assign_list()
        if Options.questions or Options.event_questions:
            att_cache = msr_get_attendee_dict()
    show_assign_results(recs, att_cache)


def do_download():
    db_open()
    recs = msr_get_assign_list()
    att_cache = msr_get_attendee_dict()
    with DB:
        for data in recs:
            msr_add_attendee_info(data, att_cache)
            db_store_assign(data)


def do_entries():
    db_open()
    with DB:
        if Options.items:
            recs = [ db_fetch_assign(item) for item in Options.items ]
        else:
            recs = db_fetch_all_assigns()
    show_assign_results(recs, fromdb=True)


def do_update():
    for rec in msr_get_changes():
        # Fetch assign(vehicle) and attendee(entry) questions
        # Apply special-case field mappings

        # BEGIN TRANSACTION
        # Ensure assign UID and all question UIDs are in database
        # This is a separate transaction so it commits even if below aborts
        # END TRANSACTION

        # BEGIN TRANSACTION
        # Compare questions against DB; compute diffs; update DB
        # Is change in database already? If so:
        # - With --force, blow away existing field diffs
        # - Otherwise, if there are no question diffs, move on to next change
        # - Otherwise, cons up a fake change to record the question diffs
        # Derive custom field values from questions
        # Derive old/new values for composite fields if any component changed
        # Figure out if this is an "interesting" change
        # Add/update change metadata
        # Add field diffs

        pass


def do_dump_changes():
    dumpobj(msr_get_changes())

def do_help(ap):
    if (Options.subcommand is not None):
        ap.parse_args([Options.subcommand, '--help'])
    else:
        ap.print_help()
    ap.exit()


def process_args():
    global Options
    ap = argparse.ArgumentParser(usage='%(prog)s [options] command [args...]')
    sp = ap.add_subparsers(title='subcommands', metavar=None)
    ap._optionals.title = 'Options'
    
    ap.add_argument('-d', '--debug', action='store_true',
            help='Enable debugging')
    ap.add_argument('-v', '--verbose', action='store_true',
            help='Enable verbose output')
    ap.add_argument('-C', '--config',     help='Config file')
    ap.add_argument('-D', '--database',   help='Database file')
    ap.add_argument('--server', help='MotorsportReg API server')
    ap.add_argument('-U', '--userid',     help='MotorsportReg username')
    ap.add_argument('-P', '--password',   help='MotorsportReg password')
    ap.add_argument(      '--pwfile',     help='File containing MotorsportReg password')
    ap.add_argument('-O', '--org-id',     help='Organization ID')
    ap.add_argument('-E', '--event-id',   help='Event ID')
    ap.add_argument('-S', '--segment-id', help='Segment ID')
    ap.add_argument('--attendee-data', type=argparse.FileType(),
            help='Prefetched attendee data file (for debug)')
    ap.add_argument('--assign-data', type=argparse.FileType(),
            help='Prefetched assignment data file (for debug)')

    p = sp.add_parser('help', help='Show help message or subcommand help')
    p.add_argument('subcommand', nargs='?', help='Subcommand to show help for')
    p.set_defaults(_func = do_help)
    p.set_defaults(_args = (ap,))

    p = sp.add_parser('events', help='List available events from MSR')
    p.add_argument('--archive', action='store_true', help='Show old events')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-x', '--dump', action='store_true', help='Dump raw data')
    p.set_defaults(_func = do_events)
    p.set_defaults(_required = opts_msr_reqd)

    p = sp.add_parser('segments', help='List event segments')
    p.add_argument('-x', '--dump', action='store_true', help='Dump raw data')
    p.set_defaults(_func = do_segments)
    p.set_defaults(_required = opts_msr_reqd + ('event-id',))

    p = sp.add_parser('attendees', help='List attendees')
    p.add_argument('items', nargs=argparse.REMAINDER, help='Attendee IDs to dump')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-q', '--questions', action='store_true', help='Include questions')
    p.add_argument('-x', '--dump', action='store_true', help='Dump raw data')
    p.set_defaults(_func = do_attendees)
    p.set_defaults(_required = opts_msr_reqd + ('event-id',))

    p = sp.add_parser('assigns', help='List assignments')
    p.add_argument('items', nargs=argparse.REMAINDER, help='Assignment IDs to dump')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-s', '--sort', action='store_true', help='Sort by class, no')
    p.add_argument('-q', '--questions',   action='store_true', help='Include all questions')
    p.add_argument('--event-questions',   action='store_true', help='Include event questions')
    p.add_argument('--vehicle-questions', action='store_true', help='Include vehicle questions')
    p.add_argument('--custom-fields',     action='store_true', help='Include custom fields')
    p.add_argument('-c', '--csv', action='store_true', help='Export CSV')
    p.add_argument('-x', '--dump', action='store_true', help='Show raw data')
    p.set_defaults(_func = do_assigns)
    p.set_defaults(_required = opts_msr_reqd + ('event-id',))

    p = sp.add_parser('download', help='Download entry data to database')
    p.set_defaults(_func = do_download)
    p.set_defaults(_required = opts_msr_reqd + ('event-id','segment-id','database'))

    p = sp.add_parser('entries', help='List downloaded entries')
    p.add_argument('items', nargs=argparse.REMAINDER, help='Assignment IDs to dump')
    p.add_argument('-l', '--long', action='store_true', help='Show more columns')
    p.add_argument('-s', '--sort', action='store_true', help='Sort by class, no')
    p.add_argument('-q', '--questions',   action='store_true', help='Include all questions')
    p.add_argument('--event-questions',   action='store_true', help='Include event questions')
    p.add_argument('--vehicle-questions', action='store_true', help='Include vehicle questions')
    p.add_argument('--custom-fields',     action='store_true', help='Include custom fields')
    p.add_argument('-c', '--csv', action='store_true', help='Export CSV')
    p.add_argument('-x', '--dump', action='store_true', help='Show raw data')
    p.set_defaults(_func = do_entries)
    p.set_defaults(_required = ('database',))

    p = sp.add_parser('dump_changes', help='Dump raw change data')
    p.add_argument('-t', '--since', type=parse_ts, help='Start time')
    p.set_defaults(_func = do_dump_changes)
    p.set_defaults(_required = opts_msr_reqd + ('event-id','segment-id'))

    Options = ap.parse_args()
    if not hasattr(Options, '_func'):
        ap.error('Missing subcommand')
    load_config()

    required = set(getattr(Options, '_required', ()))
    missing = [ x for x in required if getattr(Options, x.replace('-', '_'), None) is None ]
    if missing:
        for x in missing: sys.stderr.write("--%s is required\n" % x)
        ap.print_usage(file=sys.stderr)
        ap.exit(status=2)

    Options._func(*getattr(Options, '_args', ()))

process_args()
